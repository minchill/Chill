import discord
from discord.ext import commands
import os
import json
import random
import asyncio
import tempfile
import time
from datetime import datetime
from gtts import gTTS
import aiohttp
import io
# C·∫ßn import c√°i n√†y cho ch·ª©c nƒÉng TTS (Ph·∫ßn 5)
from discord import FFmpegPCMAudio 

# --- C·∫§U H√åNH BOT (S·ª¨ D·ª§NG BI·∫æN M√îI TR∆Ø·ªúNG) ---
# L·∫•y Token t·ª´ Bi·∫øn M√¥i Tr∆∞·ªùng DISCORD_TOKEN
TOKEN = os.getenv("DISCORD_TOKEN") 

intents = discord.Intents.default()
intents.members = True
intents.message_content = True
bot = commands.Bot(command_prefix=['!', 'b'], intents=intents)

# ----------------- DATA (JSON) -----------------
DATA_FILE = "user_data.json"

def load_data(file_name=DATA_FILE):
    """T·∫£i d·ªØ li·ªáu t·ª´ file JSON."""
    if os.path.exists(file_name):
        with open(file_name, 'r', encoding='utf-8') as f:
            try:
                return json.load(f)
            except json.JSONDecodeError:
                return {}
    return {}

def save_data(data, file_name=DATA_FILE):
    """L∆∞u d·ªØ li·ªáu v√†o file JSON."""
    with open(file_name, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=4, ensure_ascii=False)

users = load_data() 


# ----------------- DATA (JSON) -----------------
DATA_FILE = "user_data.json"

def load_data(file_name=DATA_FILE):
    """T·∫£i d·ªØ li·ªáu t·ª´ file JSON."""
    if os.path.exists(file_name):
        with open(file_name, 'r', encoding='utf-8') as f:
            try:
                return json.load(f)
            except json.JSONDecodeError:
                return {}
    return {}

def save_data(data, file_name=DATA_FILE):
    """L∆∞u d·ªØ li·ªáu v√†o file JSON."""
    with open(file_name, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=4, ensure_ascii=False)

users = load_data() 
# ----------------- D·ªÆ LI·ªÜU NG·∫™U NHI√äN & C·∫§U H√åNH PET -----------------
PET_NAMES = ["M√®o Th·∫ßn T·ªëc", "C√∫n L·ª≠a", "R·ªìng C·ªè", "Th·ªè ƒêi·ªán", "G·∫•u N∆∞·ªõc"]
PET_ELEMENTS = ["L·ª≠a", "N∆∞·ªõc", "C·ªè", "ƒêi·ªán", "ƒê·∫•t", "Gi√≥"]
SKILLS = ["T·∫•n C√¥ng M·∫°nh", "Ph√≤ng Th·ªß K√≠n", "H·ªìi M√°u", "T·ªëc ƒê·ªô Cao", "B·∫£o V·ªá"]

# C·∫•u h√¨nh Rarity (T·ªâ l·ªá ra pet)
RARITY_CHANCES = {
    "Ph·ªï Bi·∫øn": 0.50,
    "Hi·∫øm": 0.30,
    "S·ª≠ Thi": 0.15,
    "Th·∫ßn Tho·∫°i": 0.05
}

# C·∫•u h√¨nh ti·∫øn h√≥a Pet
EVOLVE_CONFIG = {
    10: {"name_suffix": " Chi·∫øn Th·∫ßn", "skill_slots": 1},
    30: {"name_suffix": " T·ªëi Th∆∞·ª£ng", "skill_slots": 2}
}

HIDDEN_PET_NAME = "Ph∆∞·ª£ng Ho√†ng L·ª≠a"
HIDDEN_PET_RARITY = "ƒê·∫•ng C·ª©u Th·∫ø"
HIDDEN_PET_DATE = (1, 1) # V√≠ d·ª•: 1/1 (Th√°ng, Ng√†y)

# C·∫•u h√¨nh ƒê√° Buff cho Hunt (√Åp d·ª•ng t·∫°m th·ªùi)
HUNT_BUFFS = {
    "ƒê√° TƒÉng T·ªâ L·ªá": {"duration": 1800, "type": "catch_chance", "value": 0.15, "desc": "TƒÉng 15% t·ªâ l·ªá b·∫Øt Pet (30 ph√∫t)."},
    "ƒê√° Nh√¢n EXP": {"duration": 1800, "type": "exp_multiplier", "value": 2.0, "desc": "Nh√¢n ƒë√¥i EXP Pet nh·∫≠n ƒë∆∞·ª£c (30 ph√∫t)."},
    "ƒê√° B√πa May M·∫Øn": {"duration": 3600, "type": "hidden_chance", "value": 0.05, "desc": "TƒÉng 5% c∆° h·ªôi b·∫Øt Pet ·∫®n (1 gi·ªù)."}
}

CHEST_NAME = "üíé R∆∞∆°ng ƒê√° Th·∫ßn" 

# D·ªØ li·ªáu v·∫≠t ph·∫©m c·ª≠a h√†ng: {t√™n: gi√°}
SHOP_ITEMS = {
    "üéÅ H·ªôp qu√†": 500,
    "üêæ Pet ng·∫´u nhi√™n": 1000,
    "üçñ Th·ª©c ƒÉn": 200, 
    "üíé ƒê√° qu√Ω": 2000 
}

# ----------------- C√ÅC H√ÄM H·ªñ TR·ª¢ ECONOMY & LEVEL -----------------

def exp_for_level(level):
    """T√≠nh EXP c·∫ßn thi·∫øt cho c·∫•p ƒë·ªô ng∆∞·ªùi ch∆°i ti·∫øp theo."""
    return 100 * level + 50 * (level ** 2)

def pet_exp_for_level(level):
    """T√≠nh EXP c·∫ßn thi·∫øt ƒë·ªÉ Pet l√™n c·∫•p ti·∫øp theo."""
    return 50 + 20 * (level ** 2)

def get_user(uid):
    """L·∫•y d·ªØ li·ªáu ng∆∞·ªùi d√πng theo ID, n·∫øu ch∆∞a c√≥ s·∫Ω t·∫°o m·ªõi."""
    key = str(uid)
    if key not in users:
        users[key] = {
            "coin": 0,
            "pets": [],
            "inventory": [],
            "last_daily": None,
            "level": 1,
            "exp": 0,
            "buffs": {}
        }
        save_data(users)
    
    if "buffs" not in users[key]:
        users[key]["buffs"] = {}
        
    for pet in users[key]["pets"]:
        pet["exp"] = pet.get("exp", 0)
        pet["level"] = pet.get("level", 1)
        pet["evolution"] = pet.get("evolution", 0)
        
    return users[key]

def update_balance(uid, amount):
    """Th√™m ho·∫∑c tr·ª´ xu."""
    user = get_user(uid)
    user["coin"] = user.get("coin", 0) + amount
    if user["coin"] < 0:
        user["coin"] = 0
    save_data(users)

def get_balance(uid):
    """L·∫•y s·ªë d∆∞ xu."""
    return get_user(uid).get("coin", 0)

def add_exp(uid, amount, ctx=None):
    """Th√™m EXP cho ng∆∞·ªùi ch∆°i v√† ki·ªÉm tra l√™n c·∫•p."""
    user = get_user(uid)
    user["exp"] += amount
    level_up = False
    
    while user["exp"] >= exp_for_level(user["level"]):
        user["exp"] -= exp_for_level(user["level"])
        user["level"] += 1
        level_up = True

    save_data(users)
    
    if level_up and ctx:
        asyncio.create_task(ctx.send(f"üéâ **{ctx.author.display_name}** ƒë√£ l√™n **C·∫•p ƒë·ªô {user['level']}**!"))
        
    return user["level"]

def random_roll_rarity():
    """Quay ng·∫´u nhi√™n t·ªâ l·ªá hi·∫øm c·ªßa pet."""
    roll = random.random()
    cumulative_chance = 0.0
    for rarity, chance in RARITY_CHANCES.items():
        cumulative_chance += chance
        if roll <= cumulative_chance:
            return rarity
    return "Ph·ªï Bi·∫øn"

def pet_power(pet):
    """T√≠nh s·ª©c m·∫°nh chi·∫øn ƒë·∫•u c·ªßa Pet."""
    base = 100 
    rarity_bonus = {"Ph·ªï Bi·∫øn": 0, "Hi·∫øm": 10, "S·ª≠ Thi": 25, "Th·∫ßn Tho·∫°i": 50, "ƒê·∫•ng C·ª©u Th·∫ø": 100}
    level_bonus = pet.get("level", 1) * 5
    
    power = base + rarity_bonus.get(pet.get("rarity", "Ph·ªï Bi·∫øn"), 0) + level_bonus
    
    power += len(pet.get("skill", "")) // 3 
    if pet.get('extra_skill_1'): power += 10
    if pet.get('extra_skill_2'): power += 20

    return power

def add_pet_exp(pet, amount):
    """Th√™m EXP cho pet, ki·ªÉm tra l√™n c·∫•p v√† ti·∫øn h√≥a."""
    initial_level = pet.get("level", 1)
    pet["exp"] = pet.get("exp", 0) + amount
    res_msg = []
    
    level_up_count = 0
    
    while pet["exp"] >= pet_exp_for_level(pet["level"]):
        level_up_count += 1
        pet["exp"] -= pet_exp_for_level(pet["level"])
        pet["level"] += 1

    if level_up_count > 0:
        res_msg.append(f"‚¨ÜÔ∏è Lv **{initial_level}** -> **{pet['level']}**!")

    for level_mark, config in EVOLVE_CONFIG.items():
        current_evolution = pet.get("evolution", 0)
        
        if pet["level"] >= level_mark > current_evolution:
            pet['name'] += config['name_suffix']
            
            for i in range(1, config['skill_slots'] + 1):
                key = f"extra_skill_{i}"
                if pet.get(key) is None:
                    current_skills = [pet.get('skill')]
                    if pet.get('extra_skill_1'): current_skills.append(pet['extra_skill_1'])
                    if pet.get('extra_skill_2'): current_skills.append(pet['extra_skill_2'])
                    
                    new_skill = random.choice([s for s in SKILLS if s not in current_skills])
                    pet[key] = new_skill
                    res_msg.append(f"üî• **{pet['name']}** ti·∫øn h√≥a! + Skill: **{new_skill}**!")

            pet["evolution"] = level_mark
            
    return res_msg
# ----------------- C√ÅC L·ªÜNH ECONOMY & PET COMMANDS -----------------

## L·ªÜNH BAL
@bot.command(name="bal", aliases=["b"])
async def balance_cmd(ctx):
    balance = get_balance(ctx.author.id)
    await ctx.send(f"üí∞ S·ªë d∆∞ c·ªßa **{ctx.author.display_name}**: **{balance:,}** xu.")

## L·ªÜNH DAILY (Th√™m R∆∞∆°ng ƒê√° Th·∫ßn)
@bot.command(name="daily", aliases=["bdaily"])
@commands.cooldown(1, 86400, commands.BucketType.user)
async def daily_cmd(ctx):
    uid = ctx.author.id
    reward = 500
    item = CHEST_NAME 
    
    user = get_user(uid)
    user["inventory"].append(item)
    update_balance(uid, reward)
    save_data(users)
    
    await ctx.send(f"üéÅ **{ctx.author.display_name}** nh·∫≠n **{reward}** xu v√† h√≤m: **{item}**!")
    await balance_cmd(ctx)

@daily_cmd.error
async def daily_error(ctx, error):
    if isinstance(error, commands.CommandOnCooldown):
        secs = int(error.retry_after)
        h = secs // 3600; m = (secs%3600)//60; s = secs%60
        await ctx.send(f"‚è∞ L·ªánh daily t√°i t·∫°o sau **{h}g {m}p {s}s**.")

## L·ªÜNH GACHA
@bot.command(name="gacha", aliases=["bgacha"])
async def gacha_cmd(ctx):
    cost = 500
    uid = ctx.author.id
    if get_balance(uid) < cost:
        return await ctx.send(f"‚ùå B·∫°n c·∫ßn **{cost}** xu ƒë·ªÉ ch∆°i Gacha.")
    
    update_balance(uid, -cost)
    reward_type = random.choice(["coin", "item", "pet"])
    
    if reward_type == "coin":
        reward = random.randint(100, 1500)
        update_balance(uid, reward)
        res = f"üéâ Quay ra **{reward:,}** xu!"
    elif reward_type == "item":
        reward = random.choice(list(SHOP_ITEMS.keys()))
        user = get_user(uid)
        user["inventory"].append(reward)
        save_data(users)
        res = f"üéÅ Quay ra v·∫≠t ph·∫©m **{reward}**!"
    elif reward_type == "pet":
        new_pet_name = random.choice(PET_NAMES)
        pet = {"name": new_pet_name, "rarity": random_roll_rarity(), "skill": random.choice(SKILLS), 
               "level":1, "exp": 0, "element": random.choice(PET_ELEMENTS), "is_hidden": False, "slot": 0, "evolution": 0}
        user = get_user(uid)
        user["pets"].append(pet)
        save_data(users)
        res = f"üéâ Quay ra Pet **{new_pet_name}** ({pet['rarity']})!"
        
    await ctx.send(f"üé≤ Gacha (gi√° {cost} xu): {res}")

## L·ªÜNH HUNT (√Åp d·ª•ng Buff)
@bot.command(name="hunt", aliases=["bhunt"])
@commands.cooldown(1, 60, commands.BucketType.user)
async def hunt_cmd(ctx):
    uid = ctx.author.id
    user = get_user(uid)
    
    # --- X·ª¨ L√ù BUFF ---
    base_catch_chance = 0.30
    base_exp_multiplier = 1.0
    base_hidden_chance = 0.01 
    
    active_buffs = {}
    current_time = int(time.time())
    
    for buff_type, buff_data in list(user["buffs"].items()):
        if buff_data["end_time"] > current_time:
            active_buffs[buff_type] = buff_data
            if buff_type == "catch_chance":
                base_catch_chance += buff_data["value"]
            elif buff_type == "exp_multiplier":
                base_exp_multiplier = buff_data["value"]
            elif buff_type == "hidden_chance":
                base_hidden_chance += buff_data["value"]
        else:
            del user["buffs"][buff_type]
            
    save_data(users)
    
    buff_msg = ""
    if active_buffs:
        buff_msg = " [Buff ƒëang ho·∫°t ƒë·ªông: " + ", ".join(d['name'] for d in active_buffs.values()) + "]"

    # --- TI·∫æN H√ÄNH HUNT ---
    final_catch_chance = min(1.0, base_catch_chance)
    
    if random.random() < final_catch_chance:
        today = datetime.now()
        rarity = random_roll_rarity()
        is_hidden = False
        
        if (today.month, today.day) == HIDDEN_PET_DATE and random.random() < base_hidden_chance:
            pet_name = HIDDEN_PET_NAME; rarity = HIDDEN_PET_RARITY; is_hidden = True
            msg = f"üåü **K·ª≥ t√≠ch!** B·∫°n t√¨m th·∫•y **{pet_name}** ({rarity})!"
        else:
            pet_name = random.choice(PET_NAMES)
            msg = f"üéâ B·∫°n b·∫Øt ƒë∆∞·ª£c Pet **{pet_name}** ({rarity})!"
            
        pet_skill = random.choice(SKILLS)
        
        pet = {"name": pet_name, "rarity": rarity, "skill": pet_skill, "level": 1, "exp": 0,
               "element": random.choice(PET_ELEMENTS), "is_hidden": is_hidden, "slot": 0, "evolution": 0}
        
        user["pets"].append(pet)
        
        initial_exp = int(random.randint(5, 20) * base_exp_multiplier)
        level_up_messages = add_pet_exp(pet, initial_exp)
        
        save_data(users)
        
        response = f"{msg}\nK·ªπ nƒÉng Pet: **{pet_skill}**."
        response += f"\n(Pet nh·∫≠n {initial_exp} EXP kh·ªüi ƒëi·ªÉm!)"
        if level_up_messages:
            response += " " + " ".join(level_up_messages)

        await ctx.send(response + buff_msg)
    else:
        update_balance(uid, 50)
        await ctx.send("üíî Kh√¥ng th·∫•y pet. Nh·∫≠n 50 xu an ·ªßi." + buff_msg)
        
    await balance_cmd(ctx)
    
@hunt_cmd.error
async def hunt_error(ctx, error):
    if isinstance(error, commands.CommandOnCooldown):
        secs = int(error.retry_after)
        await ctx.send(f"‚è∞ L·ªánh hunt t√°i t·∫°o sau **{secs}s**.")

## L·ªÜNH SHOP
@bot.command(name="bshop")
async def bshop_cmd(ctx):
    shop_list = "\n".join([f"**{item}** ‚Äî {price:,} xu" for item, price in SHOP_ITEMS.items()])
    
    embed = discord.Embed(
        title="üõçÔ∏è C·ª≠a H√†ng", 
        description=f"D√πng `!bbuy <t√™n m√≥n>` ƒë·ªÉ mua ƒë·ªì:\n\n{shop_list}", 
        color=0xffa500
    )
    embed.set_footer(text="V√≠ d·ª•: !bbuy Th·ª©c ƒÉn")
    await ctx.send(embed=embed)

## L·ªÜNH BUY
@bot.command(name="bbuy", aliases=["buy"])
async def bbuy_cmd(ctx, *, item_name: str = None):
    if not item_name:
        return await ctx.send("üõí Mua: `!bbuy <t√™n m√≥n>` (Xem !bshop)")
        
    found_item_key = next((key for key in SHOP_ITEMS if item_name.lower() in key.lower()), None)
    
    if not found_item_key:
        return await ctx.send("‚ùå M√≥n n√†y kh√¥ng c√≥ trong c·ª≠a h√†ng.")

    price = SHOP_ITEMS[found_item_key]
    user = get_user(ctx.author.id)
    
    if user["coin"] < price:
        return await ctx.send("üí∞ B·∫°n kh√¥ng ƒë·ªß xu ƒë·ªÉ mua m√≥n n√†y.")
        
    user["coin"] -= price
    user["inventory"].append(found_item_key)
    save_data(users)
    
    await ctx.send(f"‚úÖ ƒê√£ mua **{found_item_key}** v·ªõi gi√° **{price:,} xu**. Ki·ªÉm tra t√∫i ƒë·ªì b·∫±ng `!binv`.")

## L·ªÜNH INVENTORY
@bot.command(name="binv", aliases=["items", "inv"])
async def binv_cmd(ctx):
    inventory = get_user(ctx.author.id).get("inventory", [])
    if not inventory:
        return await ctx.send("üéí T√∫i ƒë·ªì tr·ªëng r·ªóng.")
        
    item_counts = {}
    for item in inventory:
        item_counts[item] = item_counts.get(item, 0) + 1
        
    items_list = "\n".join([f"‚Ä¢ **{item}** x{count}" for item, count in item_counts.items()])
    
    embed = discord.Embed(
        title=f"üéí T√∫i ƒë·ªì c·ªßa {ctx.author.display_name} ({len(inventory)} m√≥n)", 
        description=items_list, 
        color=0x40E0D0
    )
    await ctx.send(embed=embed)

## L·ªÜNH USE ITEM 
@bot.command(name="buse", aliases=["use"])
async def buse_cmd(ctx, *, item: str = None):
    if not item:
        return await ctx.send("üéÅ D√πng: `!buse <t√™n m√≥n>`")
        
    uid = ctx.author.id
    user = get_user(uid)
    inv = user.get("inventory", [])
    
    found_item = next((i for i in inv if item.lower() in i.lower()), None)
    
    if not found_item:
        return await ctx.send("‚ùå B·∫°n kh√¥ng c√≥ m√≥n n√†y.")
        
    user["inventory"].remove(found_item)
    res = ""
    
    if found_item == CHEST_NAME: 
        stone_name = random.choice(list(HUNT_BUFFS.keys()))
        user["inventory"].append(stone_name)
        res = f"üì¶ M·ªü **{CHEST_NAME}** v√† nh·∫≠n ƒë∆∞·ª£c **{stone_name}**! D√πng `!buse {stone_name}` ƒë·ªÉ k√≠ch ho·∫°t buff."
    
    elif found_item in HUNT_BUFFS: 
        buff_info = HUNT_BUFFS[found_item]
        current_time = int(time.time())
        end_time = current_time + buff_info["duration"]
        
        user["buffs"][buff_info["type"]] = {
            "end_time": end_time, 
            "value": buff_info["value"],
            "name": found_item
        }
        
        duration_str = f"{buff_info['duration'] // 60} ph√∫t" if buff_info['duration'] < 3600 else f"{buff_info['duration'] // 3600} gi·ªù"
        res = f"‚ú® ƒê√£ k√≠ch ho·∫°t **{found_item}**! {buff_info['desc']} (Hi·ªáu l·ª±c {duration_str})."
    
    elif found_item == "üêæ Pet ng·∫´u nhi√™n":
        new_pet_name = random.choice(PET_NAMES)
        pet = {"name": new_pet_name, "rarity": random_roll_rarity(), "skill": random.choice(SKILLS), 
               "level":1, "exp": 0, "element": random.choice(PET_ELEMENTS), "is_hidden": False, "slot": 0, "evolution": 0} 
        user["pets"].append(pet)
        res = f"üéâ B·∫°n nh·∫≠n Pet **{new_pet_name}**!"
    
    elif found_item == "üçñ Th·ª©c ƒÉn":
        FEED_EXP = 100
        if not user["pets"]:
            user["inventory"].append(found_item) 
            save_data(users)
            return await ctx.send("üêæ B·∫°n kh√¥ng c√≥ pet ƒë·ªÉ cho ƒÉn.")
            
        p = random.choice(user["pets"])
        level_up_messages = add_pet_exp(p, FEED_EXP)
        
        res = f"üçñ ƒê√£ cho **{p['name']}** ƒÉn. +**{FEED_EXP} EXP**."
        if level_up_messages:
            res += " " + " ".join(level_up_messages)
            
    elif found_item == "üéÅ H·ªôp qu√†":
        reward = random.randint(100, 300)
        update_balance(uid, reward)
        res = f"üéÅ M·ªü h·ªôp qu√†: +{reward} üí∞"
        
    elif found_item == "üíé ƒê√° qu√Ω":
        res = f"‚úÖ ƒê√£ s·ª≠ d·ª•ng **{found_item}** (ch∆∞a c√≥ ch·ª©c nƒÉng ƒë·∫∑c bi·ªát)."
    else:
        res = f"‚úÖ ƒê√£ s·ª≠ d·ª•ng **{found_item}** (ch∆∞a c√≥ ch·ª©c nƒÉng ƒë·∫∑c bi·ªát)."
    
    save_data(users)
    await ctx.send(res)

## L·ªÜNH ZOO
@bot.command(name="bzoo", aliases=["z","bpet","pet"])
async def bzoo_cmd(ctx):
    uid = ctx.author.id
    pets = get_user(uid).get("pets", [])
    if not pets:
        return await ctx.send("üêæ B·∫°n ch∆∞a c√≥ pet n√†o.")
    
    embed = discord.Embed(title=f"ü¶¥ Kho Pet c·ªßa {ctx.author.display_name} ({len(pets)} pet)", color=0xFEE3F5)
    for i, p in enumerate(pets, start=1):
        slot = f" [SLOT {p.get('slot')}]" if p.get("slot") else ""
        emoji = "üåü" if p.get("rarity") in ["Th·∫ßn Tho·∫°i","ƒê·∫•ng C·ª©u Th·∫ø"] else "‚ú®" if p.get("rarity") in ["S·ª≠ Thi","B√°n Th·∫ßn Tho·∫°i"] else ""
        
        skills = p['skill']
        if p.get('extra_skill_1'): skills += f", {p['extra_skill_1']}"
        if p.get('extra_skill_2'): skills += f", {p['extra_skill_2']}"
        
        exp_to_next = pet_exp_for_level(p['level'])
        
        embed.add_field(
            name=f"#{i} {p['name']}{slot}", 
            value=f"{emoji}{p['rarity']} | Lv {p['level']} (EXP: {p.get('exp', 0)}/{exp_to_next}) | {p['element']} | Skills: {skills}", 
            inline=False
        )
        
    embed.set_footer(text="D√πng !bteam add/remove <s·ªë th·ª© t·ª±> ƒë·ªÉ ch·ªânh ƒë·ªôi h√¨nh.")
    await ctx.send(embed=embed)
      # ----------------- C√ÅC L·ªÜNH BATTLE & TEAM -----------------

## L·ªÜNH BTEAM (Qu·∫£n l√Ω ƒë·ªôi pet 3v3)
@bot.group(name="bteam", aliases=["team"], invoke_without_command=True)
async def bteam_group(ctx):
    user = get_user(ctx.author.id)
    pets_in_team = sorted([p for p in user.get("pets", []) if p.get("slot", 0) > 0], key=lambda x: x['slot'])
    
    team_display = []
    for i in range(1, 4):
        pet = next((p for p in pets_in_team if p['slot'] == i), None)
        if pet:
            team_display.append(f"SLOT {i}: **{pet['name']}** (Lv {pet['level']})")
        else:
            team_display.append(f"SLOT {i}: (Tr·ªëng)")
            
    await ctx.send(f"ü¶¥ **ƒê·ªôi h√¨nh hi·ªán t·∫°i:**\n" + "\n".join(team_display) + "\n\nD√πng: `!bteam add <stt pet> <slot>` ho·∫∑c `!bteam remove <slot>`")

@bteam_group.command(name="add")
async def bteam_add(ctx, pet_index: int = None, slot: int = None):
    if pet_index is None or slot is None or slot not in [1, 2, 3]:
        return await ctx.send("‚ùå C√∫ ph√°p: `!bteam add <s·ªë th·ª© t·ª± pet> <slot (1-3)>`. (Xem stt pet b·∫±ng !bzoo)")
        
    user = get_user(ctx.author.id)
    pets = user.get("pets", [])
    
    if not (1 <= pet_index <= len(pets)):
        return await ctx.send("‚ùå S·ªë th·ª© t·ª± pet kh√¥ng h·ª£p l·ªá.")
        
    pet_to_add = pets[pet_index - 1]
    
    for p in pets:
        if p.get("slot") == slot:
            p["slot"] = 0
        if p.get("slot") == pet_to_add.get("slot"):
            p["slot"] = 0
            
    pet_to_add["slot"] = slot
    save_data(users)
    await ctx.send(f"‚úÖ ƒê√£ th√™m **{pet_to_add['name']}** (Lv {pet_to_add['level']}) v√†o **SLOT {slot}**.")

@bteam_group.command(name="remove")
async def bteam_remove(ctx, slot: int = None):
    if slot is None or slot not in [1, 2, 3]:
        return await ctx.send("‚ùå C√∫ ph√°p: `!bteam remove <slot (1-3)>`.")
        
    user = get_user(ctx.author.id)
    pets = user.get("pets", [])
    
    pet_removed = None
    for p in pets:
        if p.get("slot") == slot:
            p["slot"] = 0
            pet_removed = p["name"]
            break
            
    save_data(users)
    if pet_removed:
        await ctx.send(f"‚úÖ ƒê√£ g·ª° **{pet_removed}** kh·ªèi **SLOT {slot}**.")
    else:
        await ctx.send(f"‚ùå SLOT {slot} ƒë√£ tr·ªëng.")

## L·ªÜNH BBATTLE (3v3, pet ng∆∞·ªùi th·∫Øng nh·∫≠n EXP)
@bot.command(name="bbattle", aliases=["b"])
async def bbattle_cmd(ctx, member: discord.Member):
    if member.id == ctx.author.id:
        return await ctx.send("‚ùå Kh√¥ng th·ªÉ chi·∫øn v·ªõi ch√≠nh m√¨nh.")
        
    u1 = get_user(ctx.author.id); u2 = get_user(member.id)
    team1 = sorted([p for p in u1.get("pets",[]) if p.get("slot",0)>0], key=lambda x: x.get("slot"))[:3]
    team2 = sorted([p for p in u2.get("pets",[]) if p.get("slot",0)>0], key=lambda x: x.get("slot"))[:3]
    
    if len(team1)!=3 or len(team2)!=3:
        return await ctx.send("‚ùå C·∫£ hai c·∫ßn ƒë·ªß 3 pet trong ƒë·ªôi (d√πng !bteam add).")
        
    power1 = sum(pet_power(p) for p in team1)
    power2 = sum(pet_power(p) for p in team2)
    
    WIN = 300; LOSE = -100
    
    if power1 > power2:
        winner_id = ctx.author.id
        winner_team = team1
        res = f"üéâ **B·∫°n th·∫Øng!** Nh·∫≠n {WIN} xu."
        color = 0x00ff00
    elif power2 > power1:
        winner_id = member.id
        winner_team = team2
        res = f"üíî ƒê·ªôi ƒë·ªëi th·ªß m·∫°nh h∆°n. B·∫°n b·ªã tr·ª´ {abs(LOSE)} xu."
        color = 0xff0000
    else:
        res = "ü§ù H√≤a! Kh√¥ng ai ƒë·ªïi xu v√† kh√¥ng pet n√†o l√™n c·∫•p."
        color = 0xffff00
        winner_id = None
        winner_team = []
    
    if winner_id == ctx.author.id:
        update_balance(ctx.author.id, WIN)
        update_balance(member.id, LOSE)
    elif winner_id == member.id:
        update_balance(ctx.author.id, LOSE)
        update_balance(member.id, WIN)
        
    # --- LOGIC PET C·ªòNG EXP CHO NG∆Ø·ªúI TH·∫ÆNG ---
    exp_gain_msg = ""
    if winner_id:
        winner_user_data = get_user(winner_id)
        
        for pet_in_team in winner_team:
            original_pet = next((p for p in winner_user_data["pets"] if p.get("slot") == pet_in_team.get("slot")), None)
            
            if original_pet:
                exp_gained = random.randint(50, 150)
                level_up_messages = add_pet_exp(original_pet, exp_gained)
                
                exp_gain_msg += f"\nüèÜ Pet **{original_pet['name']}** nh·∫≠n **{exp_gained} EXP**!"
                if level_up_messages:
                    exp_gain_msg += " " + " ".join(level_up_messages)
        
        save_data(users) 
    
    em = discord.Embed(title="‚öîÔ∏è K·∫øt qu·∫£ chi·∫øn tr·∫≠n Pet", description=res, color=color)
    em.add_field(name=ctx.author.display_name, value=f"S·ª©c m·∫°nh: **{int(power1)}**", inline=True)
    em.add_field(name=member.display_name, value=f"S·ª©c m·∫°nh: **{int(power2)}**", inline=True)
    
    if exp_gain_msg:
        em.add_field(name="‚ú® Pet Nh·∫≠n EXP", value=exp_gain_msg, inline=False)
        
    await ctx.send(embed=em)

## L·ªÜNH BPVP (Th√°ch ƒë·∫•u 1v1 c∆∞·ª£c xu)
@bot.command(name="bpvp", aliases=["pvp"])
async def bpvp_cmd(ctx, member: discord.Member, amount: int):
    if member.id == ctx.author.id:
        return await ctx.send("‚ùå Kh√¥ng th·ªÉ th√°ch ƒë·∫•u ch√≠nh m√¨nh.")
        
    if amount <= 0:
        return await ctx.send("‚ùå S·ªë xu c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0.")
        
    if get_balance(ctx.author.id) < amount or get_balance(member.id) < amount:
        return await ctx.send("‚ùå M·ªôt trong hai ng∆∞·ªùi kh√¥ng ƒë·ªß xu ƒë·ªÉ c∆∞·ª£c.")
        
    u1 = get_user(ctx.author.id); u2 = get_user(member.id)
    
    pet1 = next((p for p in u1.get("pets",[]) if p.get("slot",0)==1), None)
    pet2 = next((p for p in u2.get("pets",[]) if p.get("slot",0)==1), None)
    
    if not pet1 or not pet2:
        return await ctx.send("‚ùå C·∫£ hai c·∫ßn c√≥ pet ·ªü **SLOT 1** trong ƒë·ªôi h√¨nh (d√πng !bteam add).")
        
    power1 = pet_power(pet1)
    power2 = pet_power(pet2)
    
    if power1 > power2:
        winner_id = ctx.author.id
        winner_name = ctx.author.display_name
        color = 0x00ff00
    elif power2 > power1:
        winner_id = member.id
        winner_name = member.display_name
        color = 0xff0000
    else:
        await ctx.send("ü§ù H√≤a! Kh√¥ng ai m·∫•t xu.")
        return
        
    if winner_id == ctx.author.id:
        update_balance(ctx.author.id, amount)
        update_balance(member.id, -amount)
    else:
        update_balance(ctx.author.id, -amount)
        update_balance(member.id, amount)
        
    embed = discord.Embed(title="‚öîÔ∏è K·∫øt qu·∫£ Th√°ch ƒê·∫•u Pet", color=color)
    embed.add_field(name=f"{ctx.author.display_name} (Pet: {pet1['name']})", value=f"S·ª©c m·∫°nh: **{int(power1)}**", inline=True)
    embed.add_field(name=f"{member.display_name} (Pet: {pet2['name']})", value=f"S·ª©c m·∫°nh: **{int(power2)}**", inline=True)
    embed.set_footer(text=f"Ng∆∞·ªùi th·∫Øng: {winner_name} nh·∫≠n {amount} xu.")
    
    await ctx.send(embed=embed)
      # ----------------- C√ÅC L·ªÜNH UTILITY & EVENTS -----------------

@bot.event
async def on_ready():
    print(f'ü§ñ Bot ƒë√£ s·∫µn s√†ng! ƒêƒÉng nh·∫≠p d∆∞·ªõi t√™n: {bot.user.name}')
    print(f'ID: {bot.user.id}')
    await bot.change_presence(activity=discord.Game(name="!bhelp | Pet System"))

@bot.event
async def on_message(message):
    if message.author.bot or not message.content:
        return
        
    content = message.content.lower()
    is_command = content.startswith('!') or (content.startswith('b') and len(content) > 1 and not content.startswith('b '))
    
    if content.startswith('b') and len(content) > 1 and not content.startswith('b '):
        message.content = '!' + message.content[1:]
    
    try:
        if is_command and message.channel.guild:
            ctx = await bot.get_context(message)
            if not content.startswith('!btts'):
                add_exp(message.author.id, 1, ctx=ctx) 
            
        user = get_user(message.author.id)
        if not is_command:
            gain = random.randint(1, 3)
            user["coin"] = user.get("coin", 0) + gain
            
        save_data(users)
    except Exception:
        pass
        
    await bot.process_commands(message)

## L·ªÜNH HELP
bot.remove_command("help")
@bot.command(name="bhelp", aliases=["help","commands"])
async def help_cmd(ctx):
    txt = (
        "üìö **Danh s√°ch l·ªánh** (s·ª≠ d·ª•ng ti·ªÅn t·ªë `!` ho·∫∑c `b`)\n"
        "**[C∆† B·∫¢N]**\n"
        "`bdaily` ‚Äî nh·∫≠n th∆∞·ªüng h√†ng ng√†y (c√≥ R∆∞∆°ng ƒê√° Th·∫ßn)\n"
        "`bbal` ‚Äî xem s·ªë d∆∞\n"
        "`bgacha` ‚Äî m·ªü h√≤m (500 xu)\n"
        "`bprofile` ‚Äî xem h·ªì s∆° c√° nh√¢n (c·∫•p ƒë·ªô/buff/pet/xu)\n"
        "`brank / !brank level` ‚Äî b·∫£ng x·∫øp h·∫°ng (xu/c·∫•p ƒë·ªô)\n"
        "**[PET & ITEM]**\n"
        "`bhunt` ‚Äî ƒëi sƒÉn pet (cooldown 60s, √°p d·ª•ng ƒê√° Buff)\n"
        "`bzoo` ‚Äî xem pet (hi·ªÉn th·ªã EXP/Level)\n"
        "`bshop / bbuy` ‚Äî c·ª≠a h√†ng (c√≥ Th·ª©c ƒÉn)\n"
        "`binv` ‚Äî xem ƒë·ªì\n"
        "`buse <m√≥n>` ‚Äî s·ª≠ d·ª•ng ƒë·ªì (Th·ª©c ƒÉn c·ªông EXP pet, R∆∞∆°ng m·ªü ra ƒê√° Buff)\n"
        "`bteam` ‚Äî qu·∫£n l√Ω ƒë·ªôi pet\n"
        "**[CHI·∫æN ƒê·∫§U & KH√ÅC]**\n"
        "`bbattle @ng∆∞·ªùi` ‚Äî ƒë·∫•u pet 3v3 (ng∆∞·ªùi th·∫Øng pet nh·∫≠n EXP)\n"
        "`bpvp @ng∆∞·ªùi <xu>` ‚Äî th√°ch ƒë·∫•u 1v1 c∆∞·ª£c xu\n"
        "`bbj <xu>` ‚Äî ch∆°i blackjack\n"
        "`bs <text>` ‚Äî bot ƒë·ªçc gi·ªçng (trong voice channel)\n"
    )
    await ctx.send(txt)

## L·ªÜNH PROFILE 
@bot.command(name="bprofile", aliases=["profile"])
async def bprofile_cmd(ctx, member: discord.Member = None):
    member = member or ctx.author
    data = get_user(member.id)
    
    pets_in_team = [p for p in data.get("pets", []) if p.get("slot", 0) > 0]
    pets_display = ", ".join([f"SLOT {p['slot']}: {p['name']}" for p in sorted(pets_in_team, key=lambda x: x['slot'])]) or "Kh√¥ng c√≥ pet trong ƒë·ªôi"
    
    current_level = data.get('level', 1)
    current_exp = data.get('exp', 0)
    exp_to_next = exp_for_level(current_level)
    
    active_buffs = []
    current_time = int(time.time())
    
    for buff_type, buff_data in list(data.get("buffs", {}).items()):
        if buff_data["end_time"] > current_time:
            time_left = buff_data["end_time"] - current_time
            time_str = f"{time_left // 60}m {time_left % 60}s"
            active_buffs.append(f"‚Ä¢ {buff_data['name']} (c√≤n {time_str})")
        else:
            del data["buffs"][buff_type] 
            save_data(users) 

    buffs_display = "\n".join(active_buffs) if active_buffs else "Kh√¥ng c√≥ buff n√†o."

    embed = discord.Embed(title=f"üë§ H·ªì s∆° {member.display_name}", color=0x88ccff)
    embed.set_thumbnail(url=member.display_avatar.url)
    embed.add_field(name="‚ú® C·∫•p ƒê·ªô Ng∆∞·ªùi Ch∆°i", 
                    value=f"**Lv {current_level}** | EXP: {current_exp}/{exp_to_next}", 
                    inline=False)
    embed.add_field(name="üîÆ Buffs ƒëang ho·∫°t ƒë·ªông", value=buffs_display, inline=False)
    embed.add_field(name="üí∞ Ti·ªÅn", value=f"**{data.get('coin',0):,}** xu", inline=False)
    embed.add_field(name="üêæ ƒê·ªôi Pet (3v3)", value=pets_display, inline=False)
    embed.add_field(name="üéí T·ªïng ƒê·ªì", value=f"**{len(data.get('inventory',[]))}** m√≥n", inline=True)
    embed.add_field(name="ü¶¥ T·ªïng Pet", value=f"**{len(data.get('pets',[]))}** con", inline=True)
    
    await ctx.send(embed=embed)

## L·ªÜNH RANK (X·∫øp h·∫°ng Coin v√† Level)
@bot.group(name="brank", aliases=["rank"], invoke_without_command=True)
async def brank_group(ctx):
    sorted_users = sorted(users.items(), key=lambda x: x[1].get("coin",0), reverse=True)
    lines = []
    
    for i, (uid, data) in enumerate(sorted_users[:10], start=1):
        try:
            u = await bot.fetch_user(int(uid))
            name = u.display_name.replace('`', '')
        except:
            name = f"User-{uid}"
        lines.append(f"**{i}.** {name} ‚Äî **{data.get('coin',0):,}** xu")
    
    embed = discord.Embed(
        title="üèÜ Top 10 ng∆∞·ªùi c√≥ nhi·ªÅu xu nh·∫•t",
        description="\n".join(lines) if lines else "Ch∆∞a c√≥ ai trong b·∫£ng x·∫øp h·∫°ng.",
        color=0xffd700
    )
    embed.set_footer(text="D√πng !brank level ƒë·ªÉ xem BXH c·∫•p ƒë·ªô.")
    await ctx.send(embed=embed)
    
@brank_group.command(name="level")
async def brank_level_cmd(ctx):
    sorted_users = sorted(users.items(), key=lambda x: (x[1].get("level",1), x[1].get("exp",0)), reverse=True)
    lines = []
    
    for i, (uid, data) in enumerate(sorted_users[:10], start=1):
        try:
            u = await bot.fetch_user(int(uid))
            name = u.display_name.replace('`', '')
        except:
            name = f"User-{uid}"
        lines.append(f"**{i}.** {name} ‚Äî **Lv {data.get('level',1)}** ({data.get('exp',0)} EXP)")
    
    embed = discord.Embed(
        title="‚ú® Top 10 ng∆∞·ªùi c√≥ c·∫•p ƒë·ªô cao nh·∫•t",
        description="\n".join(lines) if lines else "Ch∆∞a c√≥ ai trong b·∫£ng x·∫øp h·∫°ng.",
        color=0x40E0D0
    )
    await ctx.send(embed=embed)

## L·ªÜNH BLACKJACK
@bot.command(name="bbj", aliases=["bj"])
async def bbj_cmd(ctx, amount: int):
    if amount <= 0:
        return await ctx.send("‚ùå S·ªë xu c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0.")
        
    uid = ctx.author.id
    if get_balance(uid) < amount:
        return await ctx.send("‚ùå B·∫°n kh√¥ng ƒë·ªß xu ƒë·ªÉ c∆∞·ª£c.")
        
    def deal_card():
        return random.randint(1, 11)
        
    def calculate_score(cards):
        score = sum(cards)
        while score > 21 and 11 in cards:
            cards[cards.index(11)] = 1
            score = sum(cards)
        return score
        
    player_cards = [deal_card(), deal_card()]
    dealer_cards = [deal_card(), deal_card()]
    
    player_score = calculate_score(player_cards)
    dealer_score = calculate_score(dealer_cards)

    await ctx.send(f"üÉè **BLACKJACK!** (C∆∞·ª£c: {amount:,} xu)\n"
                   f"**B·∫°n** c√≥: {player_cards} (T·ªïng: {player_score})\n"
                   f"**Dealer** c√≥: [{dealer_cards[0]}, ?]")

    if player_score == 21:
        if dealer_score == 21:
            await ctx.send("ü§ù C·∫£ hai Blackjack! H√≤a, ho√†n l·∫°i xu.")
            return
        else:
            update_balance(uid, amount * 1.5)
            await ctx.send(f"üëë **BLACKJACK!** B·∫°n th·∫Øng {int(amount * 1.5):,} xu!")
            return

    if dealer_score == 21:
        update_balance(uid, -amount)
        await ctx.send(f"üíî Dealer Blackjack! B·∫°n m·∫•t {amount:,} xu.")
        return

    while player_score < 21:
        await ctx.send("Ch·ªçn **hit** (r√∫t th√™m) hay **stand** (d·ª´ng)? G√µ `hit` ho·∫∑c `stand`.")
        
        try:
            msg = await bot.wait_for('message', timeout=30.0, check=lambda m: m.author == ctx.author and m.channel == ctx.channel and m.content.lower() in ['hit', 'stand'])
        except asyncio.TimeoutError:
            await ctx.send("‚è∞ H·∫øt gi·ªù! T·ª± ƒë·ªông ch·ªçn stand.")
            break
            
        if msg.content.lower() == 'hit':
            new_card = deal_card()
            player_cards.append(new_card)
            player_score = calculate_score(player_cards)
            await ctx.send(f"‚ûï B·∫°n r√∫t: {new_card}. T·ªïng ƒëi·ªÉm: {player_cards} (T·ªïng: {player_score})")
            if player_score > 21:
                break
        elif msg.content.lower() == 'stand':
            break

    if player_score > 21:
        update_balance(uid, -amount)
        return await ctx.send(f"üí• **BUST!** B·∫°n v∆∞·ª£t qu√° 21. B·∫°n m·∫•t {amount:,} xu.")
        
    await ctx.send(f"\nDealer l·∫≠t b√†i: {dealer_cards} (T·ªïng: {dealer_score})")
    while dealer_score < 17:
        await asyncio.sleep(1)
        new_card = deal_card()
        dealer_cards.append(new_card)
        dealer_score = calculate_score(dealer_cards)
        await ctx.send(f"‚ûï Dealer r√∫t: {new_card}. T·ªïng ƒëi·ªÉm: {dealer_cards} (T·ªïng: {dealer_score})")
        
    if dealer_score > 21:
        update_balance(uid, amount)
        return await ctx.send(f"üéâ Dealer **BUST!** B·∫°n th·∫Øng {amount:,} xu.")

    if player_score > dealer_score:
        update_balance(uid, amount)
        await ctx.send(f"üéâ B·∫°n ({player_score}) th·∫Øng Dealer ({dealer_score})! B·∫°n th·∫Øng {amount:,} xu.")
    elif dealer_score > player_score:
        update_balance(uid, -amount)
        await ctx.send(f"üíî Dealer ({dealer_score}) th·∫Øng B·∫°n ({player_score})! B·∫°n m·∫•t {amount:,} xu.")
    else:
        await ctx.send("ü§ù H√≤a! Ho√†n l·∫°i xu.")

## L·ªÜNH TTS (Text-to-Speech)
@bot.command(name="btts", aliases=["s"])
async def tts_cmd(ctx, *, text: str):
    if not ctx.author.voice or not ctx.author.voice.channel:
        return await ctx.send("‚ùå B·∫°n ph·∫£i ·ªü trong k√™nh tho·∫°i ƒë·ªÉ bot c√≥ th·ªÉ n√≥i.")

    if ctx.voice_client and ctx.voice_client.is_connected():
        vc = ctx.voice_client
    else:
        vc = await ctx.author.voice.channel.connect()

    if vc.is_playing():
        vc.stop()

    try:
        tts = gTTS(text=text, lang='vi', slow=False)
        
        with tempfile.NamedTemporaryFile(suffix='.mp3', delete=False) as fp:
            tts.save(fp.name)
            temp_file_path = fp.name

        vc.play(discord.FFmpegPCMAudio(source=temp_file_path), 
                after=lambda e: os.remove(temp_file_path) if os.path.exists(temp_file_path) else None)
        
        await ctx.send(f"üîä Bot ƒëang n√≥i: `{text}`")
        
    except Exception as e:
        await ctx.send(f"‚ùå C√≥ l·ªói x·∫£y ra khi t·∫°o/ph√°t √¢m thanh: {e}")
        if ctx.voice_client and ctx.voice_client.is_connected():
             await ctx.voice_client.disconnect()
  # ----------------- CH·∫†Y BOT -----------------
if __name__ == "__main__":
    if not TOKEN:
        print("üö® L·ªói: Vui l√≤ng c·∫•u h√¨nh bi·∫øn m√¥i tr∆∞·ªùng DISCORD_TOKEN tr√™n Railway.")
    else:
        try:
            # ƒê·∫£m b·∫£o b·∫°n ƒë√£ k√≠ch ho·∫°t t·∫•t c·∫£ Intents c·∫ßn thi·∫øt trong Discord Developer Portal
            bot.run(TOKEN)
        except discord.errors.LoginFailure:
            print("üö® L·ªói: Token Discord kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i token c·ªßa b·∫°n.")
        except Exception as e:
            print(f"üö® L·ªói kh√¥ng x√°c ƒë·ªãnh: {e}")
