import discord
from discord.ext import commands, tasks
import os
import json
import random
import asyncio
import tempfile
import time
from datetime import datetime
from gtts import gTTS
import aiohttp
import io
from discord import FFmpegPCMAudio 

# --- C·∫§U H√åNH BOT (CH·ªà D√ôNG TI·ªÄN T·ªê 'b') ---
TOKEN = os.getenv("DISCORD_TOKEN") 

intents = discord.Intents.default()
intents.members = True
intents.message_content = True
# Ghi ƒë√® l·ªánh help m·∫∑c ƒë·ªãnh c·ªßa discord
bot = commands.Bot(command_prefix=['b'], intents=intents, help_command=None) 

# ----------------- DATA (JSON) -----------------
DATA_FILE = "user_data.json"

def load_data(file_name=DATA_FILE):
    """T·∫£i d·ªØ li·ªáu t·ª´ file JSON."""
    if os.path.exists(file_name):
        with open(file_name, 'r', encoding='utf-8') as f:
            try:
                data = json.load(f)
                if 'global_data' not in data:
                    data['global_data'] = {"last_daily_shop_update": 0, "shop_items": {}, "daily_quest": {}}
                return data
            except json.JSONDecodeError:
                return {"global_data": {"last_daily_shop_update": 0, "shop_items": {}, "daily_quest": {}}}
    return {"global_data": {"last_daily_shop_update": 0, "shop_items": {}, "daily_quest": {}}}

def save_data(data, file_name=DATA_FILE):
    """L∆∞u d·ªØ li·ªáu v√†o file JSON."""
    with open(file_name, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=4, ensure_ascii=False)

# T·∫£i d·ªØ li·ªáu v√† t√°ch users/global_data
data_store = load_data()
users = {k: v for k, v in data_store.items() if k != 'global_data'}
global_data = data_store.get('global_data', {"last_daily_shop_update": 0, "shop_items": {}, "daily_quest": {}})

# Bi·∫øn ƒë·∫øm ID to√†n c·ª•c (D√πng ƒë·ªÉ g√°n ID duy nh·∫•t cho Pet/Item)
global_pet_id_counter = 1
for user_id, user_data in users.items():
    for pet in user_data.get('pets', []):
        if pet.get('id'):
            global_pet_id_counter = max(global_pet_id_counter, pet['id'] + 1)
          # ----------------- D·ªÆ LI·ªÜU NG·∫™U NHI√äN & C·∫§U H√åNH PET -----------------
PET_NAMES = ["M√®o Th·∫ßn T·ªëc", "C√∫n L·ª≠a", "R·ªìng C·ªè", "Th·ªè ƒêi·ªán", "G·∫•u N∆∞·ªõc"]
PET_ELEMENTS = ["L·ª≠a", "N∆∞·ªõc", "C·ªè", "ƒêi·ªán", "ƒê·∫•t", "Gi√≥"]
SKILLS = ["T·∫•n C√¥ng M·∫°nh", "Ph√≤ng Th·ªß K√≠n", "H·ªìi M√°u", "T·ªëc ƒê·ªô Cao", "B·∫£o V·ªá"]
RARITY_CHANCES = {"Ph·ªï Bi·∫øn": 0.50, "Hi·∫øm": 0.30, "S·ª≠ Thi": 0.15, "Th·∫ßn Tho·∫°i": 0.05}
CHEST_NAME = "üíé R∆∞∆°ng ƒê√° Th·∫ßn" 

# --- C·∫§U H√åNH ITEM TRANG B·ªä Vƒ©nh vi·ªÖn (ƒê√É C·∫¨P NH·∫¨T) ---
PERMANENT_EQUIPMENT = {
    "R1": {"name": "‚öîÔ∏è Ki·∫øm G·ªó", "price": 2500, "sell_price": 1250, "bonus": {"ATK": 5, "HP": 0, "DEF": 0, "SPD": 0, "LUCK": 0, "EVASION": 0}},
    "R2": {"name": "üõ°Ô∏è Khi√™n S·∫Øt", "price": 5000, "sell_price": 2500, "bonus": {"ATK": 0, "HP": 50, "DEF": 5, "SPD": 0, "LUCK": 0, "EVASION": 0}},
    "R3": {"name": "üîÆ Ng·ªçc TƒÉng T·ªëc", "price": 10000, "sell_price": 5000, "bonus": {"ATK": 0, "HP": 0, "DEF": 0, "SPD": 5, "LUCK": 0, "EVASION": 0}},
    "R4": {"name": "üíé Ng·ªçc S·ª©c M·∫°nh", "price": 10000, "sell_price": 5000, "bonus": {"ATK": 10, "HP": 0, "DEF": 0, "SPD": 0, "LUCK": 0, "EVASION": 0}},
    "R5": {"name": "üçÄ T·ª© Di·ªáp Th·∫£o", "price": 15000, "sell_price": 7500, "bonus": {"ATK": 0, "HP": 0, "DEF": 0, "SPD": 0, "LUCK": 5, "EVASION": 0}},
    "R6": {"name": "üí® Gi√†y N√© ƒê√≤n", "price": 15000, "sell_price": 7500, "bonus": {"ATK": 0, "HP": 0, "DEF": 0, "SPD": 0, "LUCK": 0, "EVASION": 5}}
}

# --- C·∫§U H√åNH C√ÅC V·∫¨T PH·∫®M C·ªê ƒê·ªäNH (BASE) ---
BASE_SHOP_ITEMS = {
    "1": {"name": "üéÅ H·ªôp qu√†", "price": 500, "sell_price": 250},
    "2": {"name": "üêæ Pet ng·∫´u nhi√™n", "price": 1000, "sell_price": 500},
    "3": {"name": "üçñ Th·ª©c ƒÉn", "price": 200, "sell_price": 100}, 
    "4": {"name": "üíé ƒê√° qu√Ω", "price": 2000, "sell_price": 1000},
    "5": {"name": CHEST_NAME, "price": 3000, "sell_price": 1500}
}
HUNT_BUFFS = {
    "6": {"name": "ƒê√° TƒÉng T·ªâ L·ªá", "duration": 1800, "type": "catch_chance", "value": 0.15, "desc": "TƒÉng 15% t·ªâ l·ªá b·∫Øt Pet (30 ph√∫t).", "price": 5000, "sell_price": 2500},
    "7": {"name": "ƒê√° Nh√¢n EXP", "duration": 1800, "type": "exp_multiplier", "value": 2.0, "desc": "Nh√¢n ƒë√¥i EXP Pet nh·∫≠n ƒë∆∞·ª£c (30 ph√∫t).", "price": 5000, "sell_price": 2500},
    "8": {"name": "ƒê√° B√πa May M·∫Øn", "duration": 3600, "type": "hidden_chance", "value": 0.05, "desc": "TƒÉng 5% c∆° h·ªôi b·∫Øt Pet ·∫®n (1 gi·ªù).", "price": 10000, "sell_price": 5000}
}
for id, item in HUNT_BUFFS.items(): BASE_SHOP_ITEMS[id] = item

# --- C·∫§U H√åNH QUESTS ---
QUESTS_CONFIG = {
    "q1": {"desc": "S·ª≠ d·ª•ng l·ªánh `bh` (hunt) 5 l·∫ßn.", "reward_coin": 1000, "reward_item_id": "3", "target_count": 5, "command": "hunt"},
    "q2": {"desc": "Chi·∫øn th·∫Øng `bpve` 2 l·∫ßn.", "reward_coin": 1500, "reward_item_id": "4", "target_count": 2, "command": "pve"},
    "q3": {"desc": "Mua 1 v·∫≠t ph·∫©m t·ª´ `bshop`.", "reward_coin": 500, "reward_item_id": "1", "target_count": 1, "command": "buy"},
}

# --- C·∫§U H√åNH AUTO FIGHT & BOSS ---
WILD_PET_CONFIG = {"EXP_BASE": 100, "COIN_BASE": 150, "COOLDOWN": 120}
BOSS_CONFIG = {
    "COOLDOWN": 3600, "BOSS_NAMES": ["King L·ª≠a", "Th·ªßy T·ªôc Gi·∫≠n D·ªÆ", "L√£nh Ch√∫a Gi√≥"],
    "REWARD_ITEM_ID": "5", "EXP_BASE": 500, "COIN_BASE": 1000, "POWER_MULTIPLIER": 1.5 
}

# --- C√ÅC H√ÄM H·ªñ TR·ª¢ D·ªÆ LI·ªÜU TO√ÄN C·ª§C & SHOP ---

def save_global_data():
    """L∆∞u d·ªØ li·ªáu to√†n c·ª•c."""
    data_store = load_data()
    data_store['global_data'] = global_data
    save_data(data_store)

def update_daily_shop():
    """C·∫≠p nh·∫≠t c√°c v·∫≠t ph·∫©m ng·∫´u nhi√™n v√† c·ªë ƒë·ªãnh h√†ng ng√†y."""
    current_day = datetime.now().day
    if global_data.get('last_daily_shop_update_day') != current_day:
        
        # Ch·ªçn 3-5 item trang b·ªã ng·∫´u nhi√™n
        available_items = list(PERMANENT_EQUIPMENT.keys())
        num_items = random.randint(3, 5)
        
        # L·∫•y ID c·ªßa item trang b·ªã
        random_item_ids = random.sample(available_items, min(num_items, len(available_items)))
        
        shop_items = {}
        for item_id in random_item_ids:
            # D√πng ID g·ªëc c·ªßa item trang b·ªã (R1, R2, v.v.)
            PERMANENT_EQUIPMENT[item_id]["id"] = item_id # G√°n ID cho d·ªÖ tra c·ª©u
            shop_items[item_id] = PERMANENT_EQUIPMENT[item_id]
            
        global_data['shop_items'] = shop_items
        global_data['last_daily_shop_update_day'] = current_day
        
        # C·∫≠p nh·∫≠t Quest h√†ng ng√†y
        update_daily_quest()
        
        save_global_data()
        print("Daily shop and quest updated.")
    
    # K·∫øt h·ª£p c√°c item c·ªë ƒë·ªãnh v√† item ng·∫´u nhi√™n
    current_shop = BASE_SHOP_ITEMS.copy()
    current_shop.update(global_data.get('shop_items', {}))
    return current_shop

def update_daily_quest():
    """Thi·∫øt l·∫≠p nhi·ªám v·ª• h√†ng ng√†y m·ªõi."""
    selected_quest_id = random.choice(list(QUESTS_CONFIG.keys()))
    quest_data = QUESTS_CONFIG[selected_quest_id].copy()
    quest_data["id"] = selected_quest_id
    global_data["daily_quest"] = quest_data
    
    # Reset ti·∫øn tr√¨nh quest cho t·∫•t c·∫£ ng∆∞·ªùi d√πng
    for user_id in users:
        users[user_id]["quest_progress"] = 0
        users[user_id]["quest_claimed"] = False
    save_data(users)

def progress_quest(uid, command_name, count=1):
    """C·∫≠p nh·∫≠t ti·∫øn tr√¨nh Quest cho ng∆∞·ªùi d√πng."""
    user = get_user(uid)
    current_quest = global_data.get("daily_quest")
    
    if current_quest and not user.get("quest_claimed") and current_quest.get("command") == command_name:
        user["quest_progress"] = user.get("quest_progress", 0) + count
        user["quest_progress"] = min(user["quest_progress"], current_quest["target_count"])
        save_data(users)
        return True # ƒê√£ c·∫≠p nh·∫≠t
    return False

# --- C√ÅC H√ÄM H·ªñ TR·ª¢ PET & STATS (ƒê√É C·∫¨P NH·∫¨T) ---

def get_next_pet_id():
    global global_pet_id_counter
    new_id = global_pet_id_counter
    global_pet_id_counter += 1
    return new_id

def exp_for_level(level):
    return 100 * level + 50 * (level ** 2)

def pet_exp_for_level(level):
    return 50 + 20 * (level ** 2)

def get_base_stats(rarity):
    """T√≠nh Stats c∆° b·∫£n c·ªßa Pet d·ª±a tr√™n c·∫•p ƒë·ªô 1 v√† ƒë·ªô hi·∫øm (ƒê√É TH√äM LUCK/EVASION)."""
    base_hp = 100
    base_atk = 10
    base_def = 5
    base_spd = 5
    base_luck = 1 # Ch·ªâ s·ªë May M·∫Øn
    base_evasion = 1 # Ch·ªâ s·ªë N√© Tr√°nh
    
    # Bonus theo ƒë·ªô hi·∫øm
    rarity_bonus = {"Ph·ªï Bi·∫øn": 1.0, "Hi·∫øm": 1.1, "S·ª≠ Thi": 1.25, "Th·∫ßn Tho·∫°i": 1.5, "ƒê·∫•ng C·ª©u Th·∫ø": 2.0}
    multiplier = rarity_bonus.get(rarity, 1.0)
    
    return {
        "HP": int(base_hp * multiplier),
        "ATK": int(base_atk * multiplier),
        "DEF": int(base_def * multiplier),
        "SPD": int(base_spd * multiplier),
        "LUCK": int(base_luck * multiplier),
        "EVASION": int(base_evasion * multiplier)
    }

def get_final_stats(pet):
    """T√≠nh Stats cu·ªëi c√πng c·ªßa Pet (Base + Level Bonus + Item Bonus) (ƒê√É C·∫¨P NH·∫¨T)."""
    base_stats = get_base_stats(pet.get("rarity", "Ph·ªï Bi·∫øn"))
    level = pet.get("level", 1)
    
    final_stats = {
        "HP": base_stats["HP"] + (level * 5),
        "ATK": base_stats["ATK"] + (level * 2),
        "DEF": base_stats["DEF"] + (level * 1),
        "SPD": base_stats["SPD"] + (level * 1),
        "LUCK": base_stats["LUCK"] + (level * 0.5), # TƒÉng √≠t h∆°n
        "EVASION": base_stats["EVASION"] + (level * 0.5) # TƒÉng √≠t h∆°n
    }
    
    # --- C·ªông Stats t·ª´ Item Trang B·ªã ---
    # Ph·∫£i ki·ªÉm tra n·∫øu Pet c√≥ owner_id (tr√°nh l·ªói khi t·∫°o wild pet/boss)
    uid = pet.get('owner_id')
    if uid:
        user = get_user(uid)
        inv = user.get("inventory", [])
        
        for unique_id in pet.get("equipped_items", []):
            equipped_item_data = next((item for item in inv if item.get("unique_id") == unique_id), None)
            
            if equipped_item_data:
                shop_id = equipped_item_data["shop_id"]
                item_config = PERMANENT_EQUIPMENT.get(shop_id) or global_data.get('shop_items', {}).get(shop_id)
                
                if item_config and item_config.get("bonus"):
                    for stat, bonus in item_config["bonus"].items():
                        final_stats[stat] = final_stats.get(stat, 0) + bonus
                        
    # T√≠nh L·ª±c chi·∫øn (Power) d·ª±a tr√™n ch·ªâ s·ªë m·ªõi (Ch·ªâ s·ªë LUCK/EVASION ch·ªâ t√≠nh 1/3)
    power = final_stats["ATK"] + final_stats["DEF"] + final_stats["SPD"] + (final_stats["HP"] // 10) + (final_stats["LUCK"] // 3) + (final_stats["EVASION"] // 3)
    final_stats["POWER"] = int(power)
    
    # ƒê·∫£m b·∫£o LUCK v√† EVASION l√† s·ªë nguy√™n
    final_stats["LUCK"] = int(final_stats["LUCK"])
    final_stats["EVASION"] = int(final_stats["EVASION"])
    
    return final_stats


def get_user(uid):
    """L·∫•y d·ªØ li·ªáu ng∆∞·ªùi d√πng theo ID, n·∫øu ch∆∞a c√≥ s·∫Ω t·∫°o m·ªõi."""
    key = str(uid)
    if key not in users:
        users[key] = {
            "coin": 0, "pets": [], "inventory": [], "last_daily": None,
            "level": 1, "exp": 0, "buffs": {}, 
            "quest_progress": 0, "quest_claimed": False
        }
    
    # ƒê·∫£m b·∫£o Pet c√≥ ID v√† equipped_items
    for pet in users[key].get("pets", []):
        if 'id' not in pet: pet['id'] = get_next_pet_id()
        if 'equipped_items' not in pet: pet['equipped_items'] = [] # Danh s√°ch unique_id c·ªßa item
        if 'owner_id' not in pet: pet['owner_id'] = uid
    
    return users[key]

def update_balance(uid, amount):
    user = get_user(uid)
    user["coin"] = user.get("coin", 0) + amount
    save_data(users)

def get_balance(uid):
    return get_user(uid).get("coin", 0)

def add_exp(uid, exp, ctx=None):
    user = get_user(uid)
    user['exp'] = user.get('exp', 0) + exp
    
    while user['exp'] >= exp_for_level(user['level']):
        user['exp'] -= exp_for_level(user['level'])
        user['level'] += 1
        if ctx:
            asyncio.create_task(ctx.send(f"üéâ **{ctx.author.display_name}** ƒë·∫°t C·∫•p ƒë·ªô **{user['level']}**!"))

def random_roll_rarity():
    r = random.random()
    cumulative = 0
    for rarity, chance in RARITY_CHANCES.items():
        cumulative += chance
        if r < cumulative:
            return rarity
    return "Ph·ªï Bi·∫øn"

def add_pet_exp(pet, exp):
    messages = []
    pet["exp"] = pet.get("exp", 0) + exp
    
    while pet["exp"] >= pet_exp_for_level(pet["level"]):
        pet["exp"] -= pet_exp_for_level(pet["level"])
        pet["level"] += 1
        messages.append(f"‚¨ÜÔ∏è **{pet['name']}** l√™n Lv **{pet['level']}**!")
        
    return messages
  # ----------------- 3.1 C√ÅC L·ªÜNH ECONOMY & MUA B√ÅN -----------------

## L·ªÜNH BAL
@bot.command(name="bal")
async def balance_cmd(ctx):
    balance = get_balance(ctx.author.id)
    await ctx.send(f"üí∞ S·ªë d∆∞ c·ªßa **{ctx.author.display_name}**: **{balance:,}** xu.")

## L·ªÜNH DAILY
@bot.command(name="daily")
@commands.cooldown(1, 86400, commands.BucketType.user)
async def daily_cmd(ctx):
    uid = ctx.author.id
    reward = 500
    item_id = "5" 
    item_data = BASE_SHOP_ITEMS.get(item_id, {"name": CHEST_NAME})
    
    user = get_user(uid)
    user["inventory"].append({"shop_id": item_id, "name": item_data["name"], "unique_id": str(time.time()) + str(random.randint(0, 1000))})
    update_balance(uid, reward)
    save_data(users)
    
    await ctx.send(f"üéÅ **{ctx.author.display_name}** nh·∫≠n **{reward}** xu v√† h√≤m: **{item_data['name']}**!")

@daily_cmd.error
async def daily_error(ctx, error):
    if isinstance(error, commands.CommandOnCooldown):
        secs = int(error.retry_after)
        h = secs // 3600; m = (secs%3600)//60; s = secs%60
        await ctx.send(f"‚è∞ L·ªánh daily t√°i t·∫°o sau **{h}g {m}p {s}s**.")

## L·ªÜNH HUNT (R√öT G·ªåN: h - C·∫≠p nh·∫≠t Logic Luck)
@bot.command(name="hunt", aliases=["h"])
@commands.cooldown(1, 60, commands.BucketType.user)
async def hunt_cmd(ctx):
    uid = ctx.author.id
    user = get_user(uid)
    
    # --- X·ª¨ L√ù BUFF --- (Gi·ªØ nguy√™n)
    base_catch_chance = 0.30; base_exp_multiplier = 1.0; base_hidden_chance = 0.01 
    active_buffs = {}; current_time = int(time.time())
    
    for buff_id, buff_data in list(user["buffs"].items()):
        if buff_data["end_time"] > current_time:
            active_buffs[buff_id] = buff_data
            if buff_data["type"] == "catch_chance": base_catch_chance += buff_data["value"]
            elif buff_data["type"] == "exp_multiplier": base_exp_multiplier = buff_data["value"]
            elif buff_data["type"] == "hidden_chance": base_hidden_chance += buff_data["value"]
        else:
            del user["buffs"][buff_id]
            
    # --- √Åp d·ª•ng Pet Luck v√†o t·ªâ l·ªá b·∫Øt Pet ---
    # L·∫•y Pet Slot 1 (ho·∫∑c Pet c√≥ LUCK cao nh·∫•t)
    player_pet = next((p for p in user.get("pets", []) if p.get("slot", 0) == 1), None)
    luck_bonus = 0
    if player_pet:
        pet_stats = get_final_stats(player_pet)
        # M·ªói 10 ƒëi·ªÉm LUCK tƒÉng 1% t·ªâ l·ªá b·∫Øt
        luck_bonus = pet_stats['LUCK'] / 100.0 
    
    save_data(users)
    buff_msg = " [Buff ƒëang ho·∫°t ƒë·ªông: " + ", ".join(d['name'] for d in active_buffs.values()) + "]" if active_buffs else ""

    # --- TI·∫æN H√ÄNH HUNT ---
    final_catch_chance = min(1.0, base_catch_chance + luck_bonus)
    
    if random.random() < final_catch_chance:
        progress_quest(uid, "hunt") # C·∫≠p nh·∫≠t Quest
        
        rarity = random_roll_rarity(); is_hidden = False
        pet_name = random.choice(PET_NAMES)
        
        pet_data = {"id": get_next_pet_id(), "name": pet_name, "rarity": rarity, "skill": random.choice(SKILLS), "level": 1, "exp": 0,
               "element": random.choice(PET_ELEMENTS), "is_hidden": is_hidden, "slot": 0, "evolution": 0, "owner_id": uid, "equipped_items": []}
        
        user["pets"].append(pet_data)
        initial_exp = int(random.randint(5, 20) * base_exp_multiplier)
        level_up_messages = add_pet_exp(pet_data, initial_exp)
        save_data(users)
        
        response = f"üéâ B·∫°n b·∫Øt ƒë∆∞·ª£c Pet **{pet_name}** ({rarity})! [ID: {pet_data['id']}]"
        response += f"\n(Pet nh·∫≠n {initial_exp} EXP kh·ªüi ƒëi·ªÉm! T·ªâ l·ªá b·∫Øt: {final_catch_chance*100:.1f}%)"
        if level_up_messages: response += " " + " ".join(level_up_messages)
        await ctx.send(response + buff_msg)
    else:
        update_balance(uid, 50)
        await ctx.send(f"üíî Kh√¥ng th·∫•y pet. Nh·∫≠n 50 xu an ·ªßi. (T·ªâ l·ªá b·∫Øt: {final_catch_chance*100:.1f}%)" + buff_msg)
        
    await balance_cmd(ctx)
    
@hunt_cmd.error
async def hunt_error(ctx, error):
    if isinstance(error, commands.CommandOnCooldown):
        secs = int(error.retry_after)
        await ctx.send(f"‚è∞ L·ªánh hunt t√°i t·∫°o sau **{secs}s**.")

## L·ªÜNH SHOP (shop)
@bot.command(name="shop")
async def shop_cmd(ctx):
    current_shop = update_daily_shop() 
    
    shop_list = "\n".join([f"‚Ä¢ **{item['name']}** (ID: {id}) ‚Äî {item['price']:,} xu" 
                           for id, item in current_shop.items()])
    
    embed = discord.Embed(
        title="üõçÔ∏è C·ª≠a H√†ng (C·∫≠p nh·∫≠t h√†ng ng√†y)", 
        description=f"D√πng `bbuy <ID m√≥n>` ƒë·ªÉ mua ƒë·ªì:\n\n{shop_list}", 
        color=0xffa500
    )
    embed.set_footer(text="V√≠ d·ª•: bbuy 3 (mua Th·ª©c ƒÉn)")
    await ctx.send(embed=embed)

## L·ªÜNH BUY (buy - C·∫≠p nh·∫≠t Quest)
@bot.command(name="buy")
async def buy_cmd(ctx, item_id: str = None):
    current_shop = update_daily_shop()
    if not item_id or item_id not in current_shop:
        return await ctx.send("üõí Mua: `bbuy <ID m√≥n>` (Xem bshop ƒë·ªÉ bi·∫øt ID).")
        
    item_data = current_shop[item_id]
    price = item_data["price"]
    item_name = item_data["name"]
    uid = ctx.author.id; user = get_user(uid)
    
    if user["coin"] < price:
        return await ctx.send("üí∞ B·∫°n kh√¥ng ƒë·ªß xu ƒë·ªÉ mua m√≥n n√†y.")
        
    user["coin"] -= price
    user["inventory"].append({"shop_id": item_id, "name": item_name, "unique_id": str(time.time()) + str(random.randint(0, 1000))})
    
    progress_quest(uid, "buy") # C·∫≠p nh·∫≠t Quest
    save_data(users)
    
    await ctx.send(f"‚úÖ ƒê√£ mua **{item_name}** (Shop ID: {item_id}) v·ªõi gi√° **{price:,} xu**. Ki·ªÉm tra t√∫i ƒë·ªì b·∫±ng `binv`.")

## L·ªÜNH SELL (B√°n ƒë·ªì theo ID duy nh·∫•t)
@bot.command(name="sell")
async def sell_cmd(ctx, unique_id: str = None):
    if not unique_id: return await ctx.send("üí∞ B√°n: `bsell <ID m√≥n trong t√∫i>` (Xem ID trong `binv`).")
        
    uid = ctx.author.id; user = get_user(uid); inv = user.get("inventory", [])
    item_to_sell_data = next((item for item in inv if item.get("unique_id") == unique_id), None)
    
    if not item_to_sell_data: return await ctx.send(f"‚ùå B·∫°n kh√¥ng c√≥ v·∫≠t ph·∫©m c√≥ ID **{unique_id}** trong t√∫i ƒë·ªì.")
    
    # Ki·ªÉm tra xem item c√≥ ƒëang ƒë∆∞·ª£c pet n√†o trang b·ªã kh√¥ng
    for pet in user["pets"]:
        if unique_id in pet.get("equipped_items", []):
            return await ctx.send(f"‚ùå V·∫≠t ph·∫©m **{item_to_sell_data['name']}** ƒëang ƒë∆∞·ª£c Pet **{pet['name']}** trang b·ªã. D√πng `bunequip <ID pet> <ID t√∫i>` tr∆∞·ªõc khi b√°n.")

    shop_id = item_to_sell_data["shop_id"]
    shop_item_data = BASE_SHOP_ITEMS.get(shop_id) or PERMANENT_EQUIPMENT.get(shop_id) or global_data.get('shop_items', {}).get(shop_id)
    sell_price = shop_item_data.get("sell_price", 100) if shop_item_data else 100
    
    user["inventory"].remove(item_to_sell_data)
    update_balance(uid, sell_price)
    save_data(users)
    
    await ctx.send(f"‚úÖ ƒê√£ b√°n **{item_to_sell_data['name']}** (ID: {unique_id}) v·ªõi gi√° **{sell_price:,} xu**.")
    await balance_cmd(ctx)


## L·ªÜNH INVENTORY (inv, hi·ªÉn th·ªã ID duy nh·∫•t)
@bot.command(name="inv", aliases=["items"])
async def inv_cmd(ctx):
    inventory = get_user(ctx.author.id).get("inventory", [])
    if not inventory: return await ctx.send("üéí T√∫i ƒë·ªì tr·ªëng r·ªóng.")
        
    item_list = []
    for item in inventory:
        # Ki·ªÉm tra xem item c√≥ ƒëang ƒë∆∞·ª£c trang b·ªã kh√¥ng
        equipped_to = ""
        for pet in get_user(ctx.author.id)["pets"]:
            if item.get("unique_id") in pet.get("equipped_items", []):
                equipped_to = f" (Trang b·ªã cho Pet ID: {pet['id']})"
                break
                
        item_list.append(f"‚Ä¢ **{item['name']}** (Shop ID: {item['shop_id']}) - ID T√∫i: `{item['unique_id']}`{equipped_to}")
    
    embed = discord.Embed(
        title=f"üéí T√∫i ƒë·ªì c·ªßa {ctx.author.display_name} ({len(inventory)} m√≥n)", 
        description=f"D√πng `b equip <ID t√∫i> <ID pet>` | `b use <ID t√∫i>` | `b sell <ID t√∫i>`:\n\n" + "\n".join(item_list[:20]), # Gi·ªõi h·∫°n 20 m√≥n
        color=0x40E0D0
    )
    if len(inventory) > 20: embed.set_footer(text=f"V√† {len(inventory) - 20} m√≥n kh√°c...")
    await ctx.send(embed=embed)
  # ----------------- 3.2 C√ÅC L·ªÜNH S·ª¨ D·ª§NG ITEM, PET & MINIGAMES -----------------

## L·ªÜNH USE ITEM 
@bot.command(name="use")
async def use_cmd(ctx, unique_id: str = None):
    # Logic gi·ªØ nguy√™n
    if not unique_id: return await ctx.send("üéÅ D√πng: `b use <ID m√≥n trong t√∫i>` (Xem ID trong `binv`).")
    uid = ctx.author.id; user = get_user(uid); inv = user.get("inventory", [])
    item_to_use = next((item for item in inv if item.get("unique_id") == unique_id), None)
    if not item_to_use: return await ctx.send(f"‚ùå B·∫°n kh√¥ng c√≥ v·∫≠t ph·∫©m c√≥ ID t√∫i **{unique_id}**.")

    shop_id = item_to_use["shop_id"]; item_name = item_to_use["name"]
    
    if shop_id in PERMANENT_EQUIPMENT or shop_id in global_data.get('shop_items', {}):
        return await ctx.send(f"‚ùå V·∫≠t ph·∫©m **{item_name}** l√† trang b·ªã. D√πng `b equip <ID t√∫i> <ID pet>`.")

    user["inventory"].remove(item_to_use)
    res = ""
    
    if shop_id == "5": # R∆∞∆°ng ƒê√° Th·∫ßn
        stone_id = random.choice(list(HUNT_BUFFS.keys()))
        stone_data = BASE_SHOP_ITEMS[stone_id]
        user["inventory"].append({"shop_id": stone_id, "name": stone_data["name"], "unique_id": str(time.time()) + str(random.randint(0, 1000))})
        res = f"üì¶ M·ªü **{CHEST_NAME}** v√† nh·∫≠n ƒë∆∞·ª£c **{stone_data['name']}**! D√πng `b use <ID>` ƒë·ªÉ k√≠ch ho·∫°t buff."
    
    elif shop_id in ["6", "7", "8"]: # ƒê√° Buff
        buff_info = HUNT_BUFFS[shop_id]
        current_time = int(time.time()); end_time = current_time + buff_info["duration"]
        user["buffs"][buff_info["type"]] = {"end_time": end_time, "value": buff_info["value"], "name": buff_info["name"]}
        duration_str = f"{buff_info['duration'] // 60} ph√∫t" if buff_info['duration'] < 3600 else f"{buff_info['duration'] // 3600} gi·ªù"
        res = f"‚ú® ƒê√£ k√≠ch ho·∫°t **{item_name}**! {buff_info['desc']} (Hi·ªáu l·ª±c {duration_str})."
    
    elif shop_id == "2": # Pet ng·∫´u nhi√™n
        new_pet_name = random.choice(PET_NAMES)
        pet = {"id": get_next_pet_id(), "name": new_pet_name, "rarity": random_roll_rarity(), "skill": random.choice(SKILLS), 
               "level":1, "exp": 0, "element": random.choice(PET_ELEMENTS), "is_hidden": False, "slot": 0, "evolution": 0, "owner_id": uid, "equipped_items": []} 
        user["pets"].append(pet)
        res = f"üéâ B·∫°n nh·∫≠n Pet **{new_pet_name}** [ID: {pet['id']}]!"
    
    elif shop_id == "3": # Th·ª©c ƒÉn
        FEED_EXP = 100
        if not user["pets"]:
            user["inventory"].append(item_to_use); save_data(users)
            return await ctx.send("üêæ B·∫°n kh√¥ng c√≥ pet ƒë·ªÉ cho ƒÉn.")
            
        p = random.choice(user["pets"])
        level_up_messages = add_pet_exp(p, FEED_EXP)
        res = f"üçñ ƒê√£ cho **{p['name']}** ƒÉn. +**{FEED_EXP} EXP**."
        if level_up_messages: res += " " + " ".join(level_up_messages)
            
    elif shop_id == "1": # H·ªôp qu√†
        reward = random.randint(100, 300)
        update_balance(uid, reward)
        res = f"üéÅ M·ªü h·ªôp qu√†: +{reward} üí∞"
        
    else:
        res = f"‚úÖ ƒê√£ s·ª≠ d·ª•ng **{item_name}** (Shop ID: {shop_id})."
    
    save_data(users)
    await ctx.send(res)


## L·ªÜNH ZOO (z - C·∫≠p nh·∫≠t hi·ªÉn th·ªã Stats m·ªõi)
@bot.command(name="zoo", aliases=["z","pet"])
async def zoo_cmd(ctx):
    uid = ctx.author.id; pets = get_user(uid).get("pets", [])
    if not pets: return await ctx.send("üêæ B·∫°n ch∆∞a c√≥ pet n√†o.")
    
    embed = discord.Embed(title=f"ü¶¥ Kho Pet c·ªßa {ctx.author.display_name} ({len(pets)} pet)", color=0xFEE3F5)
    for i, p in enumerate(pets, start=1):
        stats = get_final_stats(p)
        slot = f" [SLOT {p.get('slot')}]" if p.get("slot") else ""
        exp_to_next = pet_exp_for_level(p['level'])
        
        equipped_names = [next(item['name'] for item in get_user(uid)['inventory'] if item['unique_id'] == iid) for iid in p.get('equipped_items', [])]
        equipped_str = f" | Trang b·ªã: {', '.join(equipped_names)}" if equipped_names else ""
        
        embed.add_field(
            name=f"#{i} {p['name']}{slot} (ID Pet: {p.get('id', 'N/A')})", 
            value=f"‚ú® {p['rarity']} | Lv {p['level']} | P: **{stats['POWER']}**\n"
                  f"üìä HP: {stats['HP']} | ATK: {stats['ATK']} | DEF: {stats['DEF']}\n"
                  f"üçÄ LUCK: {stats['LUCK']} | üí® EVASION: {stats['EVASION']} | SPD: {stats['SPD']}\n"
                  f"EXP: {p.get('exp', 0)}/{exp_to_next}{equipped_str}", 
            inline=False
        )
        
    embed.set_footer(text="D√πng bteam add/remove <s·ªë th·ª© t·ª±> ƒë·ªÉ ch·ªânh ƒë·ªôi h√¨nh. D√πng b equip/unequip.")
    await ctx.send(embed=embed)

## L·ªÜNH EQUIP / UNEQUIP (Trang b·ªã v√† G·ª° b·ªè trang b·ªã)
@bot.command(name="equip")
async def equip_cmd(ctx, unique_id: str = None, pet_id: int = None):
    if not unique_id or pet_id is None: 
        return await ctx.send("‚ùå C√∫ ph√°p: `b equip <ID t√∫i> <ID pet>` (Xem ID t√∫i b·∫±ng `binv`, ID pet b·∫±ng `bz`).")
        
    uid = ctx.author.id; user = get_user(uid); inv = user.get("inventory", [])
    item_to_equip = next((item for item in inv if item.get("unique_id") == unique_id), None)
    pet = next((p for p in user.get("pets", []) if p.get("id") == pet_id), None)
    
    if not item_to_equip: return await ctx.send(f"‚ùå Kh√¥ng t√¨m th·∫•y item v·ªõi ID t√∫i `{unique_id}`.")
    if not pet: return await ctx.send(f"‚ùå Kh√¥ng t√¨m th·∫•y Pet v·ªõi ID `{pet_id}`.")
    
    shop_id = item_to_equip["shop_id"]
    item_config = PERMANENT_EQUIPMENT.get(shop_id) or global_data.get('shop_items', {}).get(shop_id)
    
    if not item_config or 'bonus' not in item_config:
        return await ctx.send(f"‚ùå Item **{item_to_equip['name']}** kh√¥ng ph·∫£i l√† trang b·ªã (kh√¥ng c√≥ ch·ªâ s·ªë bonus).")

    if unique_id in pet.get("equipped_items", []):
        return await ctx.send(f"‚ùå Item n√†y ƒë√£ ƒë∆∞·ª£c trang b·ªã cho Pet **{pet['name']}** r·ªìi.")
        
    if unique_id in [i for p in user["pets"] for i in p.get("equipped_items", [])]:
        return await ctx.send(f"‚ùå Item n√†y ƒë√£ ƒë∆∞·ª£c Pet kh√°c trang b·ªã. D√πng `bunequip` tr∆∞·ªõc.")

    # Trang b·ªã
    pet["equipped_items"] = pet.get("equipped_items", []) + [unique_id]
    save_data(users)
    await ctx.send(f"‚úÖ ƒê√£ trang b·ªã **{item_to_equip['name']}** cho Pet **{pet['name']}** (ID: {pet_id}).")

@bot.command(name="unequip", aliases=["un"])
async def unequip_cmd(ctx, pet_id: int = None, unique_id: str = None):
    if pet_id is None or unique_id is None:
        return await ctx.send("‚ùå C√∫ ph√°p: `b unequip <ID pet> <ID t√∫i>`.")
        
    uid = ctx.author.id; user = get_user(uid)
    pet = next((p for p in user.get("pets", []) if p.get("id") == pet_id), None)
    item_to_unequip = next((item for item in user.get("inventory", []) if item.get("unique_id") == unique_id), None)

    if not pet: return await ctx.send(f"‚ùå Kh√¥ng t√¨m th·∫•y Pet v·ªõi ID `{pet_id}`.")
    if not item_to_unequip: return await ctx.send(f"‚ùå Kh√¥ng t√¨m th·∫•y Item v·ªõi ID t√∫i `{unique_id}`.")

    if unique_id in pet.get("equipped_items", []):
        pet["equipped_items"].remove(unique_id)
        save_data(users)
        await ctx.send(f"‚úÖ ƒê√£ g·ª° **{item_to_unequip['name']}** kh·ªèi Pet **{pet['name']}** (ID: {pet_id}).")
    else:
        await ctx.send(f"‚ùå Item **{item_to_unequip['name']}** kh√¥ng ƒë∆∞·ª£c trang b·ªã cho Pet **{pet['name']}**.")

## L·ªÜNH QUEST (Nhi·ªám v·ª• h√†ng ng√†y)
@bot.command(name="quest")
async def quest_cmd(ctx):
    current_quest = global_data.get("daily_quest")
    if not current_quest:
        update_daily_shop()
        current_quest = global_data.get("daily_quest")
        
    if not current_quest:
        return await ctx.send("‚ùå Hi·ªán t·∫°i ch∆∞a c√≥ nhi·ªám v·ª• n√†o ƒë∆∞·ª£c thi·∫øt l·∫≠p. Vui l√≤ng ch·ªù 24h t·ª´ l·∫ßn ch·∫°y bot g·∫ßn nh·∫•t.")

    uid = ctx.author.id; user = get_user(uid)
    
    if user.get("quest_claimed"):
        status = "‚úÖ ƒê√É NH·∫¨N TH∆Ø·ªûNG!"
    else:
        progress = user.get("quest_progress", 0)
        target = current_quest["target_count"]
        status = f"ƒê√£ ho√†n th√†nh: **{progress}/{target}**"
        if progress >= target:
            status += " (S·∫µn s√†ng nh·∫≠n th∆∞·ªüng!)"

    reward_item_data = BASE_SHOP_ITEMS.get(current_quest["reward_item_id"]) or PERMANENT_EQUIPMENT.get(current_quest["reward_item_id"])
    reward_item_name = reward_item_data["name"] if reward_item_data else "V·∫≠t ph·∫©m b√≠ ·∫©n"

    embed = discord.Embed(
        title="üìú Nhi·ªám V·ª• H√†ng Ng√†y", 
        description=f"**M√¥ t·∫£:** {current_quest['desc']}",
        color=0x9B59B6
    )
    embed.add_field(name="üí∞ Ph·∫ßn Th∆∞·ªüng", value=f"{current_quest['reward_coin']:,} xu + **{reward_item_name}**", inline=False)
    embed.add_field(name="üéØ T√¨nh Tr·∫°ng", value=status, inline=False)
    embed.set_footer(text="D√πng bclaim ƒë·ªÉ nh·∫≠n th∆∞·ªüng khi ho√†n th√†nh.")
    await ctx.send(embed=embed)

@bot.command(name="claim")
async def claim_cmd(ctx):
    current_quest = global_data.get("daily_quest")
    if not current_quest: return await ctx.send("‚ùå Hi·ªán t·∫°i kh√¥ng c√≥ nhi·ªám v·ª• ƒë·ªÉ nh·∫≠n th∆∞·ªüng.")

    uid = ctx.author.id; user = get_user(uid)
    
    if user.get("quest_claimed"):
        return await ctx.send("‚ùå B·∫°n ƒë√£ nh·∫≠n th∆∞·ªüng nhi·ªám v·ª• h√¥m nay r·ªìi.")
        
    progress = user.get("quest_progress", 0)
    target = current_quest["target_count"]
    
    if progress < target:
        return await ctx.send(f"‚ùå B·∫°n c·∫ßn ho√†n th√†nh nhi·ªám v·ª• **{progress}/{target}** tr∆∞·ªõc khi nh·∫≠n th∆∞·ªüng.")
        
    # Th∆∞·ªüng
    reward_coin = current_quest["reward_coin"]
    reward_item_id = current_quest["reward_item_id"]
    reward_item_data = BASE_SHOP_ITEMS.get(reward_item_id) or PERMANENT_EQUIPMENT.get(reward_item_id)
    reward_item_name = reward_item_data["name"] if reward_item_data else "V·∫≠t ph·∫©m b√≠ ·∫©n"
    
    update_balance(uid, reward_coin)
    user["inventory"].append({"shop_id": reward_item_id, "name": reward_item_name, "unique_id": str(time.time()) + str(random.randint(0, 1000))})
    user["quest_claimed"] = True
    add_exp(uid, 10, ctx=ctx)
    save_data(users)
    
    await ctx.send(f"üéâ **CH√öC M·ª™NG!** B·∫°n ƒë√£ ho√†n th√†nh v√† nh·∫≠n th∆∞·ªüng nhi·ªám v·ª•: **{reward_coin:,} xu** v√† **{reward_item_name}**!")

## L·ªÜNH BLACKJACK (BBJ) - D√πng Icon ƒë·ªÉ t∆∞∆°ng t√°c
@bot.command(name="bj", aliases=["bbj"])
async def bbj_cmd(ctx, amount: int = None):
    # ------------------ KH·ªûI T·∫†O & C∆Ø·ª¢C ------------------
    uid = ctx.author.id
    if amount is None or amount <= 0: return await ctx.send("‚ùå C√∫ ph√°p: `bbj <s·ªë xu c∆∞·ª£c>`.")
    if get_balance(uid) < amount: return await ctx.send("üí∞ B·∫°n kh√¥ng ƒë·ªß xu ƒë·ªÉ c∆∞·ª£c.")
    
    def get_card_value(card):
        if card in ["K", "Q", "J"]: return 10
        if card == "A": return 11
        return int(card)
        
    def calculate_score(hand):
        score = sum(get_card_value(card) for card in hand)
        aces = hand.count("A")
        while score > 21 and aces > 0:
            score -= 10
            aces -= 1
        return score
    
    deck = ["2","3","4","5","6","7","8","9","10","J","Q","K","A"] * 4
    random.shuffle(deck)
    def deal_card(): return deck.pop()
        
    player_hand = [deal_card(), deal_card()]
    dealer_hand = [deal_card(), deal_card()]
    
    # ------------------ H√ÄM HI·ªÇN TH·ªä EMBED ------------------
    def create_embed(game_state, hide_dealer=True):
        player_score = calculate_score(player_hand)
        dealer_display = dealer_hand[0] + ", [?]" if hide_dealer else ", ".join(dealer_hand)
        dealer_score = "?" if hide_dealer else calculate_score(dealer_hand)
        
        embed = discord.Embed(
            title="‚ô†Ô∏è BLACKJACK ‚ô£Ô∏è",
            description=f"**C∆∞·ª£c:** {amount:,} xu",
            color=0x2ECC71
        )
        embed.add_field(name=f"B·∫°n ({player_score})", value=f"B√†i: {', '.join(player_hand)}", inline=False)
        embed.add_field(name=f"Bot ({dealer_score})", value=f"B√†i: {dealer_display}", inline=False)
        
        if game_state == "playing":
            embed.set_footer(text="Nh·∫•n ‚ûï (R√∫t) ho·∫∑c ‚úã (D·ª´ng) | ‚ùå (Tho√°t)")
        elif game_state == "end":
             embed.set_footer(text="Tr√≤ ch∆°i ƒë√£ k·∫øt th√∫c!")
             
        return embed
        
    # ------------------ G·ª¨I TIN NH·∫ÆN V√Ä TH√äM REACTIONS ------------------
    game_message = await ctx.send(embed=create_embed("playing"))
    await game_message.add_reaction("‚ûï")
    await game_message.add_reaction("‚úã")
    await game_message.add_reaction("‚ùå")
    
    # ------------------ V√íNG L·∫∂P CH·ªú T∆Ø∆†NG T√ÅC ------------------
    def check(reaction, user):
        return user == ctx.author and reaction.message.id == game_message.id and str(reaction.emoji) in ["‚ûï", "‚úã", "‚ùå"]

    while calculate_score(player_hand) < 21:
        try:
            reaction, user = await bot.wait_for('reaction_add', timeout=30.0, check=check)
        except asyncio.TimeoutError:
            await game_message.edit(embed=create_embed("end"), content="‚è∞ H·∫øt gi·ªù! Tr√≤ ch∆°i b·ªã h·ªßy.")
            return

        await game_message.remove_reaction(reaction.emoji, user)

        if str(reaction.emoji) == "‚ùå":
            await game_message.edit(embed=create_embed("end"), content="üíî Tr√≤ ch∆°i b·ªã h·ªßy.")
            return
            
        elif str(reaction.emoji) == "‚úã":
            break
            
        elif str(reaction.emoji) == "‚ûï":
            player_hand.append(deal_card())
            player_score = calculate_score(player_hand)
            await game_message.edit(embed=create_embed("playing"))
            if player_score > 21: break
                
    # ------------------ X·ª¨ L√ù K·∫æT QU·∫¢ CU·ªêI C√ôNG ------------------
    player_score = calculate_score(player_hand); dealer_score = calculate_score(dealer_hand)
    result_msg = ""
    
    if player_score > 21:
        result_msg = "üí• **Bust!** B·∫°n b·ªã qu√° 21 ƒëi·ªÉm. Thua c∆∞·ª£c."
        update_balance(uid, -amount)
    else:
        while dealer_score < 17:
            dealer_hand.append(deal_card())
            dealer_score = calculate_score(dealer_hand)

        if dealer_score > 21:
            result_msg = "üéâ **DEALER BUST!** Bot b·ªã qu√° 21 ƒëi·ªÉm. B·∫°n th·∫Øng!"
            update_balance(uid, amount)
        elif player_score > dealer_score:
            result_msg = "üéâ **BLACKJACK!** B·∫°n c√≥ ƒëi·ªÉm cao h∆°n. B·∫°n th·∫Øng!"
            update_balance(uid, amount)
        elif player_score < dealer_score:
            result_msg = "üíî **DEALER TH·∫ÆNG!** Bot c√≥ ƒëi·ªÉm cao h∆°n. Thua c∆∞·ª£c."
            update_balance(uid, -amount)
        else:
            result_msg = "ü§ù **PUSH!** H√≤a ƒëi·ªÉm. Kh√¥ng ai m·∫•t ti·ªÅn."
            
    final_embed = create_embed("end", hide_dealer=False)
    await game_message.edit(embed=final_embed, content=f"{result_msg}\n")
    
    await balance_cmd(ctx)
  # ----------------- C√ÅC L·ªÜNH BATTLE & TEAM -----------------

def simple_battle(pet1, pet2, exp_bonus=1.0):
    """M√¥ ph·ªèng tr·∫≠n ƒë·∫•u 1v1 ƒë∆°n gi·∫£n d·ª±a tr√™n Stats (ƒê√É TH√äM EVASION)."""
    stats1 = get_final_stats(pet1); stats2 = get_final_stats(pet2)
    hp1 = stats1["HP"]; hp2 = stats2["HP"]
    
    # T·ªâ l·ªá N√© tr√°nh (Evasion) = EVASION / (EVASION + 100) (t·ªëi ƒëa 50%)
    evasion_chance1 = stats1["EVASION"] / (stats1["EVASION"] + 100)
    evasion_chance2 = stats2["EVASION"] / (stats2["EVASION"] + 100)
    
    # T·ªâ l·ªá S√°t th∆∞∆°ng ch√≠ m·∫°ng (Critical) = LUCK / 200 (t·ªëi ƒëa 50%)
    crit_chance1 = stats1["LUCK"] / 200.0
    crit_chance2 = stats2["LUCK"] / 200.0
    
    # Gi·ªõi h·∫°n t·ªâ l·ªá n√©/crit t·ªëi ƒëa (v√≠ d·ª• 50%)
    evasion_chance1 = min(0.5, evasion_chance1)
    evasion_chance2 = min(0.5, evasion_chance2)
    crit_chance1 = min(0.5, crit_chance1)
    crit_chance2 = min(0.5, crit_chance2)
    
    # Chi·∫øn ƒë·∫•u theo l∆∞·ª£t (t·ªëi ƒëa 20 l∆∞·ª£t)
    for _ in range(20):
        # L∆∞·ª£t Pet 1 t·∫•n c√¥ng Pet 2
        if random.random() > evasion_chance2: # Pet 2 kh√¥ng n√©
            damage1 = max(1, stats1["ATK"] - stats2["DEF"])
            if random.random() < crit_chance1: # Ch√≠ m·∫°ng
                damage1 = damage1 * 2
            hp2 -= damage1
            if hp2 <= 0: return pet1, pet2 # Pet 1 th·∫Øng
        
        # L∆∞·ª£t Pet 2 t·∫•n c√¥ng Pet 1
        if random.random() > evasion_chance1: # Pet 1 kh√¥ng n√©
            damage2 = max(1, stats2["ATK"] - stats1["DEF"])
            if random.random() < crit_chance2: # Ch√≠ m·∫°ng
                damage2 = damage2 * 2
            hp1 -= damage2
            if hp1 <= 0: return pet2, pet1 # Pet 2 th·∫Øng

    # N·∫øu h√≤a sau 20 l∆∞·ª£t, Pet n√†o c√≤n HP cao h∆°n th·∫Øng
    if hp1 > hp2: return pet1, pet2
    if hp2 > hp1: return pet2, pet1
    return None, None # H√≤a

## L·ªÜNH PVP (1v1, c∆∞·ª£c xu - Ch·ªâ d√πng Pet SLOT 1)
@bot.command(name="pvp")
async def pvp_cmd(ctx, member: discord.Member, amount: int):
    # Logic gi·ªØ nguy√™n (1v1, c∆∞·ª£c xu, ch·ªâ d√πng Pet SLOT 1)
    if member.id == ctx.author.id: return await ctx.send("‚ùå Kh√¥ng th·ªÉ th√°ch ƒë·∫•u ch√≠nh m√¨nh.")
    if amount <= 0: return await ctx.send("‚ùå S·ªë xu c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0.")
    if get_balance(ctx.author.id) < amount or get_balance(member.id) < amount: return await ctx.send("‚ùå M·ªôt trong hai ng∆∞·ªùi kh√¥ng ƒë·ªß xu ƒë·ªÉ c∆∞·ª£c.")
        
    u1 = get_user(ctx.author.id); u2 = get_user(member.id)
    pet1 = next((p for p in u1.get("pets",[]) if p.get("slot",0)==1), None)
    pet2 = next((p for p in u2.get("pets",[]) if p.get("slot",0)==1), None)
    if not pet1 or not pet2: return await ctx.send("‚ùå C·∫£ hai c·∫ßn c√≥ pet ·ªü **SLOT 1** trong ƒë·ªôi h√¨nh (d√πng bteam add).")
        
    winner, loser = simple_battle(pet1, pet2)
    
    if winner is None:
        await ctx.send("ü§ù H√≤a! Kh√¥ng ai m·∫•t xu.")
        return
        
    is_author_winner = winner.get('owner_id') == ctx.author.id
    winner_id = ctx.author.id if is_author_winner else member.id
    winner_name = ctx.author.display_name if is_author_winner else member.display_name
    
    if is_author_winner:
        update_balance(ctx.author.id, amount); update_balance(member.id, -amount); color = 0x00ff00
    else:
        update_balance(ctx.author.id, -amount); update_balance(member.id, amount); color = 0xff0000
        
    stats1 = get_final_stats(pet1); stats2 = get_final_stats(pet2)
    embed = discord.Embed(title="‚öîÔ∏è K·∫øt qu·∫£ Th√°ch ƒê·∫•u Pet (1v1)", color=color)
    embed.add_field(name=f"{ctx.author.display_name} (Pet: {pet1['name']})", value=f"P: {stats1['POWER']} | ATK: {stats1['ATK']} | EVASION: {stats1['EVASION']}", inline=False)
    embed.add_field(name=f"{member.display_name} (Pet: {pet2['name']})", value=f"P: {stats2['POWER']} | ATK: {stats2['ATK']} | EVASION: {stats2['EVASION']}", inline=False)
    embed.set_footer(text=f"Ng∆∞·ªùi th·∫Øng: {winner_name} nh·∫≠n {amount} xu.")
    
    await ctx.send(embed=embed)


## L·ªÜNH PVP LINH HO·∫†T (Team Fight)
def team_battle(team1, team2):
    """M√¥ ph·ªèng tr·∫≠n ƒë·∫•u Team vs Team ƒë∆°n gi·∫£n (Sum Stats)."""
    # Sum of all key stats
    total_stats1 = {"HP": 0, "ATK": 0, "DEF": 0, "SPD": 0, "LUCK": 0, "EVASION": 0}
    for pet in team1:
        stats = get_final_stats(pet)
        for key in total_stats1: total_stats1[key] += stats[key]
        
    total_stats2 = {"HP": 0, "ATK": 0, "DEF": 0, "SPD": 0, "LUCK": 0, "EVASION": 0}
    for pet in team2:
        stats = get_final_stats(pet)
        for key in total_stats2: total_stats2[key] += stats[key]
        
    # M√¥ ph·ªèng chi·∫øn ƒë·∫•u: T·ªâ l·ªá th·∫Øng d·ª±a tr√™n t·ªïng Power
    # Power = ATK + DEF + (HP/10) + (SPD) + (LUCK/3) + (EVASION/3)
    power1 = total_stats1["ATK"] + total_stats1["DEF"] + (total_stats1["HP"] // 10) + total_stats1["SPD"] + (total_stats1["LUCK"] // 3) + (total_stats1["EVASION"] // 3)
    power2 = total_stats2["ATK"] + total_stats2["DEF"] + (total_stats2["HP"] // 10) + total_stats2["SPD"] + (total_stats2["LUCK"] // 3) + (total_stats2["EVASION"] // 3)
    
    win_chance = power1 / (power1 + power2)
    
    if random.random() < win_chance: return 1, power1, power2 # Team 1 th·∫Øng
    if random.random() < (1 - win_chance): return 2, power1, power2 # Team 2 th·∫Øng
    return 0, power1, power2 # H√≤a

@bot.command(name="fight")
async def fight_cmd(ctx, member: discord.Member):
    if member.id == ctx.author.id: return await ctx.send("‚ùå Kh√¥ng th·ªÉ chi·∫øn v·ªõi ch√≠nh m√¨nh.")
        
    u1 = get_user(ctx.author.id); u2 = get_user(member.id)
    team1 = sorted([p for p in u1.get("pets",[]) if p.get("slot",0)>0], key=lambda x: x.get("slot"))[:3]
    team2 = sorted([p for p in u2.get("pets",[]) if p.get("slot",0)>0], key=lambda x: x.get("slot"))[:3]
    
    if not team1 or not team2: return await ctx.send("‚ùå C·∫£ hai c·∫ßn c√≥ √≠t nh·∫•t 1 Pet trong ƒë·ªôi h√¨nh (d√πng bteam add).")
        
    winner_team_index, power1, power2 = team_battle(team1, team2)
    WIN = 300; LOSE = -100
    
    if winner_team_index == 1:
        update_balance(ctx.author.id, WIN); update_balance(member.id, LOSE)
        winner_id = ctx.author.id; winner_team = team1; res = f"üéâ **B·∫°n th·∫Øng!** Nh·∫≠n {WIN} xu."; color = 0x00ff00
    elif winner_team_index == 2:
        update_balance(ctx.author.id, LOSE); update_balance(member.id, WIN)
        winner_id = member.id; winner_team = team2; res = f"üíî ƒê·ªôi ƒë·ªëi th·ªß m·∫°nh h∆°n. B·∫°n b·ªã tr·ª´ {abs(LOSE)} xu."; color = 0xff0000
    else:
        res = "ü§ù H√≤a! Kh√¥ng ai ƒë·ªïi xu v√† kh√¥ng pet n√†o l√™n c·∫•p."; color = 0xffff00; winner_id = None; winner_team = []
        
    exp_gain_msg = ""
    if winner_id:
        winner_user_data = get_user(winner_id)
        for pet_in_team in winner_team:
            original_pet = next((p for p in winner_user_data["pets"] if p.get("id") == pet_in_team.get("id")), None)
            if original_pet:
                exp_gained = random.randint(50, 150)
                level_up_messages = add_pet_exp(original_pet, exp_gained)
                exp_gain_msg += f"\nüèÜ Pet **{original_pet['name']}** nh·∫≠n **{exp_gained} EXP**!"
                if level_up_messages: exp_gain_msg += " " + " ".join(level_up_messages)
        save_data(users) 
    
    em = discord.Embed(title=f"‚öîÔ∏è K·∫øt qu·∫£ chi·∫øn tr·∫≠n Pet ({len(team1)}v{len(team2)})", description=res, color=color)
    em.add_field(name=f"{ctx.author.display_name} ({len(team1)} Pet)", value=f"T·ªïng L·ª±c Chi·∫øn: **{int(power1)}**", inline=True)
    em.add_field(name=f"{member.display_name} ({len(team2)} Pet)", value=f"T·ªïng L·ª±c Chi·∫øn: **{int(power2)}**", inline=True)
    
    if exp_gain_msg: em.add_field(name="‚ú® Pet Nh·∫≠n EXP", value=exp_gain_msg, inline=False)
    await ctx.send(embed=em)

## L·ªÜNH AUTO FIGHT (PVE - C·∫≠p nh·∫≠t Logic Luck/Battle)
@bot.command(name="pve", aliases=["af"])
@commands.cooldown(1, WILD_PET_CONFIG["COOLDOWN"], commands.BucketType.user)
async def pve_cmd(ctx):
    uid = ctx.author.id; user = get_user(uid)
    player_pet = next((p for p in user.get("pets", []) if p.get("slot", 0) == 1), None)
    if not player_pet: return await ctx.send("‚ùå B·∫°n c·∫ßn c√≥ Pet ·ªü **SLOT 1** trong ƒë·ªôi h√¨nh ƒë·ªÉ chi·∫øn ƒë·∫•u.")
        
    # T·∫°o Pet hoang d√£ (d·ª±a tr√™n c·∫•p ƒë·ªô c·ªßa ng∆∞·ªùi ch∆°i)
    player_level = player_pet['level']
    wild_level = random.randint(player_level - 5, player_level + 5); wild_level = max(1, wild_level)
    wild_name = random.choice(PET_NAMES)
    wild_rarity = random.choice(list(RARITY_CHANCES.keys()))
    
    # Pet hoang d√£ kh√¥ng c√≥ owner_id
    wild_pet_data = {"id": 0, "name": wild_name, "rarity": wild_rarity, "level": wild_level, 
                     "owner_id": 0, "equipped_items": []} # Pet t·∫°m th·ªùi
    
    winner, loser = simple_battle(player_pet, wild_pet_data)
    
    if winner and winner.get('owner_id') == uid:
        progress_quest(uid, "pve") # C·∫≠p nh·∫≠t Quest
        
        # √Åp d·ª•ng LUCK ƒë·ªÉ tƒÉng th∆∞·ªüng
        player_stats = get_final_stats(player_pet)
        luck_multiplier = 1 + (player_stats['LUCK'] / 50.0) # V√≠ d·ª•: 50 LUCK = x2 th∆∞·ªüng
        
        coin_gain = int((WILD_PET_CONFIG["COIN_BASE"] + random.randint(0, 50)) * luck_multiplier)
        exp_gain = int((WILD_PET_CONFIG["EXP_BASE"] + random.randint(0, 50)) * luck_multiplier)
        update_balance(uid, coin_gain); level_up_messages = add_pet_exp(player_pet, exp_gain)
        add_exp(uid, 5, ctx=ctx); save_data(users)
        
        wild_stats = get_final_stats(wild_pet_data)
        
        res_msg = f"üéâ **Chi·∫øn Th·∫Øng!** Pet **{player_pet['name']}** (P: {player_stats['POWER']}) ƒë√£ ƒë√°nh b·∫°i **{wild_name}** (P: {wild_stats['POWER']})!"
        res_msg += f"\nüí∞ B·∫°n nh·∫≠n **{coin_gain:,}** xu. üèÜ Pet nh·∫≠n **{exp_gain} EXP**."
        if level_up_messages: res_msg += " " + " ".join(level_up_messages)
        await ctx.send(res_msg)
    else:
        coin_lose = random.randint(50, 100); exp_lose = random.randint(10, 30)
        update_balance(uid, -coin_lose); player_pet["exp"] = max(0, player_pet["exp"] - exp_lose)
        save_data(users)
        
        wild_stats = get_final_stats(wild_pet_data)
        res_msg = f"üíî **Th·∫•t B·∫°i!** Pet **{player_pet['name']}** (P: {player_stats['POWER']}) ƒë√£ b·ªã **{wild_name}** (P: {wild_stats['POWER']}) ƒë√°nh b·∫°i."
        res_msg += f"\nüìâ B·∫°n b·ªã tr·ª´ **{coin_lose}** xu. Pet m·∫•t **{exp_lose} EXP**."
        await ctx.send(res_msg)

@pve_cmd.error
async def pve_error(ctx, error):
    if isinstance(error, commands.CommandOnCooldown):
        secs = int(error.retry_after)
        await ctx.send(f"‚è∞ L·ªánh PVE t√°i t·∫°o sau **{secs} gi√¢y**.")

## L·ªÜNH AUTO FIGHT BOSS (boss - C·∫≠p nh·∫≠t Logic Battle)
@bot.command(name="boss", aliases=["bfboss"])
@commands.cooldown(1, BOSS_CONFIG["COOLDOWN"], commands.BucketType.user)
async def boss_cmd(ctx):
    uid = ctx.author.id; user = get_user(uid)
    player_pet = next((p for p in user.get("pets", []) if p.get("slot", 0) == 1), None)
    if not player_pet: return await ctx.send("‚ùå B·∫°n c·∫ßn c√≥ Pet ·ªü **SLOT 1** ƒë·ªÉ th√°ch ƒë·∫•u Boss.")
        
    boss_name = random.choice(BOSS_CONFIG["BOSS_NAMES"])
    boss_level = max(10, player_pet['level'] + 5)
    
    boss_rarity = "Th·∫ßn Tho·∫°i"
    boss_pet_data = {"id": 0, "name": boss_name, "rarity": boss_rarity, "level": boss_level, 
                     "owner_id": 0, "equipped_items": []} # Pet t·∫°m th·ªùi
    
    # Nh√¢n Stats Boss l√™n (Gi·∫£ l·∫≠p Boss m·∫°nh h∆°n)
    boss_stats = get_final_stats(boss_pet_data)
    boss_stats["HP"] = int(boss_stats["HP"] * BOSS_CONFIG["POWER_MULTIPLIER"])
    boss_stats["ATK"] = int(boss_stats["ATK"] * BOSS_CONFIG["POWER_MULTIPLIER"])
    
    # Boss v·∫´n b·ªã ƒë√°nh b·∫°i nh∆∞ pet th∆∞·ªùng
    winner, loser = simple_battle(player_pet, boss_pet_data) 
    
    if winner and winner.get('owner_id') == uid:
        item_data = BASE_SHOP_ITEMS[BOSS_CONFIG["REWARD_ITEM_ID"]]
        coin_gain = BOSS_CONFIG["COIN_BASE"] + random.randint(100, 500)
        exp_gain = BOSS_CONFIG["EXP_BASE"] + random.randint(100, 300)
        
        update_balance(uid, coin_gain)
        user["inventory"].append({"shop_id": BOSS_CONFIG["REWARD_ITEM_ID"], "name": item_data["name"], "unique_id": str(time.time()) + str(random.randint(0, 1000))})
        level_up_messages = add_pet_exp(player_pet, exp_gain)
        add_exp(uid, 20, ctx=ctx); save_data(users)
        
        res_msg = f"üëë **ƒê·∫†I TH·∫ÆNG BOSS!** Pet **{player_pet['name']}** ƒë√£ h·∫° g·ª•c Boss **{boss_name}** (P: {boss_stats['POWER']})!"
        res_msg += f"\nüí∞ B·∫°n nh·∫≠n **{coin_gain:,}** xu. üéÅ Nh·∫≠n **{item_data['name']}**."
        res_msg += f"üèÜ Pet nh·∫≠n **{exp_gain} EXP**."
        if level_up_messages: res_msg += " " + " ".join(level_up_messages)
        await ctx.send(res_msg)
    else:
        coin_lose = random.randint(200, 400); exp_lose = random.randint(50, 100)
        update_balance(uid, -coin_lose); player_pet["exp"] = max(0, player_pet["exp"] - exp_lose)
        save_data(users)
        
        res_msg = f"üíî **TH·∫§T B·∫†I TR∆Ø·ªöC BOSS!** Boss **{boss_name}** (P: {boss_stats['POWER']}) qu√° m·∫°nh."
        res_msg += f"\nüìâ B·∫°n b·ªã tr·ª´ **{coin_lose}** xu. Pet m·∫•t **{exp_lose} EXP**."
        await ctx.send(res_msg)

@boss_cmd.error
async def boss_error(ctx, error):
    if isinstance(error, commands.CommandOnCooldown):
        secs = int(error.retry_after)
        h = secs // 3600; m = (secs%3600)//60; s = secs%60
        await ctx.send(f"‚è∞ L·ªánh Boss t√°i t·∫°o sau **{h}g {m}p {s}s**.")


# --- L·ªÜNH TEAM (GROUP) ---
@bot.group(name="team")
async def team_group(ctx):
    if ctx.invoked_subcommand is None:
        await ctx.send("‚ùå C√∫ ph√°p: `bteam <add/remove/show>`.")

@team_group.command(name="add")
async def team_add(ctx, pet_number: int = None, slot: int = 1):
    uid = ctx.author.id; user = get_user(uid); pets = user.get("pets", [])
    if pet_number is None or slot not in [1, 2, 3]: 
        return await ctx.send("‚ùå C√∫ ph√°p: `bteam add <s·ªë th·ª© t·ª± pet> <slot 1/2/3>` (Xem s·ªë th·ª© t·ª± trong `bz`).")
    if pet_number <= 0 or pet_number > len(pets): 
        return await ctx.send("‚ùå S·ªë th·ª© t·ª± pet kh√¥ng h·ª£p l·ªá.")
        
    pet = pets[pet_number - 1]
    
    # Lo·∫°i b·ªè pet c≈© ·ªü slot n·∫øu c√≥
    for p in pets:
        if p.get("slot") == slot:
            p["slot"] = 0
            break
            
    # Th√™m pet m·ªõi v√†o slot
    pet["slot"] = slot
    save_data(users)
    await ctx.send(f"‚úÖ Pet **{pet['name']}** ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t v√†o **SLOT {slot}**.")

@team_group.command(name="remove")
async def team_remove(ctx, slot: int = 1):
    uid = ctx.author.id; user = get_user(uid); pets = user.get("pets", [])
    if slot not in [1, 2, 3]: return await ctx.send("‚ùå Slot kh√¥ng h·ª£p l·ªá (1, 2 ho·∫∑c 3).")
        
    pet_in_slot = next((p for p in pets if p.get("slot") == slot), None)
    
    if pet_in_slot:
        pet_in_slot["slot"] = 0
        save_data(users)
        await ctx.send(f"‚úÖ Pet **{pet_in_slot['name']}** ƒë√£ ƒë∆∞·ª£c g·ª° kh·ªèi **SLOT {slot}**.")
    else:
        await ctx.send(f"‚ùå SLOT {slot} ƒë√£ tr·ªëng.")

@team_group.command(name="show")
async def team_show(ctx):
    uid = ctx.author.id; pets = get_user(uid).get("pets", [])
    team = sorted([p for p in pets if p.get("slot", 0) > 0], key=lambda x: x.get("slot"))
    
    if not team: return await ctx.send("üêæ ƒê·ªôi h√¨nh c·ªßa b·∫°n ƒëang tr·ªëng. D√πng `bteam add <stt pet> <slot>`.")
    
    team_list = ""
    for p in team:
        stats = get_final_stats(p)
        team_list += f"**SLOT {p['slot']}**: {p['name']} (Lv {p['level']} | P: {stats['POWER']})\n"
        
    embed = discord.Embed(title=f"‚öîÔ∏è ƒê·ªôi H√¨nh Chi·∫øn ƒê·∫•u c·ªßa {ctx.author.display_name}", description=team_list, color=0x5865F2)
    await ctx.send(embed=embed)

# --- L·ªÜNH PROFILE ---
@bot.command(name="profile")
async def profile_cmd(ctx, member: discord.Member = None):
    member = member or ctx.author
    user = get_user(member.id)
    
    total_pets = len(user.get("pets", []))
    total_inventory = len(user.get("inventory", []))
    
    embed = discord.Embed(
        title=f"üë§ H·ªì S∆° Pet Master: {member.display_name}",
        color=0x3498DB
    )
    
    # Th√¥ng tin c∆° b·∫£n
    embed.add_field(name="üí∞ Xu hi·ªán t·∫°i", value=f"{user.get('coin', 0):,} xu", inline=True)
    embed.add_field(name="‚ú® C·∫•p ƒë·ªô Master", value=f"Lv {user.get('level', 1)}", inline=True)
    embed.add_field(name="üêæ Pet ƒë√£ s·ªü h·ªØu", value=f"{total_pets} Pet", inline=True)
    embed.add_field(name="üéí T√∫i ƒë·ªì", value=f"{total_inventory} m√≥n", inline=True)
    
    # Team hi·ªán t·∫°i
    team = sorted([p for p in user.get("pets", []) if p.get("slot", 0) > 0], key=lambda x: x.get("slot"))
    team_names = ", ".join([p["name"] for p in team]) if team else "Ch∆∞a thi·∫øt l·∫≠p"
    embed.add_field(name="‚öîÔ∏è ƒê·ªôi h√¨nh", value=team_names, inline=False)
    
    # Buffs ƒëang ho·∫°t ƒë·ªông
    active_buffs_str = ""
    current_time = int(time.time())
    
    for buff_id, buff_data in user.get("buffs", {}).items():
        if buff_data["end_time"] > current_time:
            time_left = buff_data["end_time"] - current_time
            h = time_left // 3600; m = (time_left % 3600) // 60
            active_buffs_str += f"‚Ä¢ **{buff_data['name']}** (C√≤n: {h}g {m}p)\n"
            
    if active_buffs_str:
        embed.add_field(name="‚ú® Buff Ho·∫°t ƒê·ªông", value=active_buffs_str, inline=False)

    embed.set_thumbnail(url=member.display_avatar.url)
    embed.set_footer(text=f"ID: {member.id}")
    await ctx.send(embed=embed)
  # ----------------- C√ÅC L·ªÜNH UTILITY & EVENTS -----------------

@tasks.loop(hours=24)
async def daily_shop_update_task():
    """T·ª± ƒë·ªông c·∫≠p nh·∫≠t shop v√† quest h√†ng ng√†y."""
    await bot.wait_until_ready()
    update_daily_shop()

@bot.event
async def on_ready():
    print(f'ü§ñ Bot ƒë√£ s·∫µn s√†ng! ƒêƒÉng nh·∫≠p d∆∞·ªõi t√™n: {bot.user.name}')
    await bot.change_presence(activity=discord.Game(name="bhelp | Pet System"))
    # Ch·∫°y c·∫≠p nh·∫≠t shop v√† quest ngay khi bot kh·ªüi ƒë·ªông
    update_daily_shop()
    daily_shop_update_task.start()

@bot.event
async def on_message(message):
    if message.author.bot or not message.content:
        return
        
    content = message.content.lower()
    is_command = content.startswith('b') and len(content) > 1 and not content.startswith('b ')
    
    try:
        if is_command and message.channel.guild:
            ctx = await bot.get_context(message)
            
            # X·ª≠ l√Ω Quest Progress cho c√°c l·ªánh
            if ctx.command and ctx.command.name in ["hunt", "h"]: progress_quest(message.author.id, "hunt")
            elif ctx.command and ctx.command.name in ["pve", "af"]: progress_quest(message.author.id, "pve")
            elif ctx.command and ctx.command.name in ["buy"]: progress_quest(message.author.id, "buy")

            # C·ªông EXP cho l·ªánh (tr·ª´ tts)
            if ctx.command and ctx.command.name not in ["tts", "s"]:
                add_exp(message.author.id, 1, ctx=ctx) 
            
        # Logic ki·∫øm xu ng·∫´u nhi√™n
        user = get_user(message.author.id)
        if not is_command:
            gain = random.randint(1, 3)
            user["coin"] = user.get("coin", 0) + gain
            
        save_data(users)
    except Exception:
        pass 
        
    await bot.process_commands(message)

## L·ªÜNH HELP (ƒê√É CH·∫∂N L·ªÜNH C≈® B·∫∞NG C√ÅCH D√ôNG help_command=None ·ªü Ph·∫ßn 1)
@bot.command(name="help", aliases=["commands", "hlep"])
async def help_cmd(ctx):
    txt = (
        "üìö **Danh s√°ch l·ªánh** (s·ª≠ d·ª•ng ti·ªÅn t·ªë **`b`**)\n"
        "**[C∆† B·∫¢N]**\n"
        "`bhelp` ‚Äî Hi·ªÉn th·ªã danh s√°ch l·ªánh n√†y\n"
        "`bdaily` ‚Äî nh·∫≠n th∆∞·ªüng h√†ng ng√†y\n"
        "`bbal` ‚Äî xem s·ªë d∆∞\n"
        "`bprofile` ‚Äî xem h·ªì s∆° c√° nh√¢n\n"
        "`bquest / bclaim` ‚Äî nhi·ªám v·ª• h√†ng ng√†y / nh·∫≠n th∆∞·ªüng\n"
        "**[PET & ITEM]**\n"
        "`bh` ‚Äî ƒëi sƒÉn pet (cooldown 60s)\n"
        "`bpve` ‚Äî **PVE**: ƒê·∫•u qu√°i v·∫≠t c√†y EXP/xu (cooldown 120s)\n"
        "`bboss` ‚Äî **Boss**: ƒê·∫•u Boss nh·∫≠n th∆∞·ªüng kh·ªßng (cooldown 1h)\n"
        "`bz` ‚Äî xem Pet (c√≥ ID pet v√† Stats)\n"
        "`bshop / bbuy <ID>` ‚Äî c·ª≠a h√†ng (mua b·∫±ng ID)\n"
        "`binv / buse <ID> / bsell <ID>` ‚Äî t√∫i ƒë·ªì / d√πng ƒë·ªì / b√°n ƒë·ªì (b·∫±ng ID t√∫i)\n"
        "`bteam <add/remove/show>` ‚Äî qu·∫£n l√Ω ƒë·ªôi pet\n"
        "`b equip <ID t√∫i> <ID pet>` ‚Äî trang b·ªã item cho pet\n"
        "**[CHI·∫æN ƒê·∫§U & KH√ÅC]**\n"
        "`bfight @ng∆∞·ªùi` ‚Äî ƒë·∫•u Pet linh ho·∫°t theo ƒë·ªôi h√¨nh\n"
        "`bpvp @ng∆∞·ªùi <xu>` ‚Äî th√°ch ƒë·∫•u 1v1 c∆∞·ª£c xu\n"
        "`bbj <xu>` ‚Äî ch∆°i blackjack (d√πng icon ‚ûï/‚úã)\n"
        "`bs <text>` ‚Äî bot ƒë·ªçc gi·ªçng (trong voice channel, alias cho `btts`)\n"
    )
    await ctx.send(txt)

## L·ªÜNH TEXT TO SPEECH (tts, r√∫t g·ªçn: s)
@bot.command(name="tts", aliases=["s"])
async def tts_cmd(ctx, *, text: str):
    if not ctx.author.voice or not ctx.author.voice.channel:
        return await ctx.send("‚ùå B·∫°n ph·∫£i ·ªü trong m·ªôt k√™nh tho·∫°i ƒë·ªÉ d√πng l·ªánh n√†y.")

    # Gi·ªõi h·∫°n ƒë·ªô d√†i text ƒë·ªÉ tr√°nh t·∫°o file qu√° l·ªõn
    if len(text) > 200:
        return await ctx.send("‚ùå VƒÉn b·∫£n qu√° d√†i. Vui l√≤ng nh·∫≠p t·ªëi ƒëa 200 k√Ω t·ª±.")
        
    temp_file_path = None
    try:
        # 1. T·∫°o file √¢m thanh t·∫°m th·ªùi
        tts = gTTS(text=text, lang='vi')
        with tempfile.NamedTemporaryFile(suffix=".mp3", delete=False) as tmp:
            tts.write_to_fp(tmp)
            temp_file_path = tmp.name

        # 2. K·∫øt n·ªëi v√† ph√°t √¢m thanh
        if ctx.voice_client is None:
            vc = await ctx.author.voice.channel.connect()
        else:
            vc = ctx.voice_client
        
        if vc.is_playing():
            vc.stop()
            
        # S·ª≠ d·ª•ng FFmpegPCMAudio. Sau khi c√†i FFmpeg b·∫±ng Dockerfile, l·ªánh n√†y s·∫Ω ho·∫°t ƒë·ªông.
        # 'after' ƒë·∫£m b·∫£o file t·∫°m ƒë∆∞·ª£c x√≥a sau khi ph√°t xong
        vc.play(FFmpegPCMAudio(temp_file_path), after=lambda e: os.remove(temp_file_path) if temp_file_path and os.path.exists(temp_file_path) else None)
        await ctx.message.add_reaction("üîä")
        
    except Exception as e:
        # In l·ªói chi ti·∫øt ra console v√† g·ª≠i tin nh·∫Øn l·ªói
        print(f"L·ªñI TTS X·∫¢Y RA: {e}")
        await ctx.send(f"‚ùå C√≥ l·ªói x·∫£y ra khi t·∫°o/ph√°t √¢m thanh: {e}")
        
    finally:
        # ƒê·∫£m b·∫£o file temp ƒë∆∞·ª£c x√≥a n·∫øu c√≥ l·ªói tr∆∞·ªõc khi ph√°t
        if temp_file_path and os.path.exists(temp_file_path) and not ctx.voice_client.is_playing():
             os.remove(temp_file_path)

@bot.command(name="leave", aliases=["disconnect", "dc"])
async def leave_cmd(ctx):
    if ctx.voice_client:
        await ctx.guild.voice_client.disconnect()
        await ctx.send("üëã ƒê√£ ng·∫Øt k·∫øt n·ªëi kh·ªèi k√™nh tho·∫°i.")
    else:
        await ctx.send("‚ùå Bot kh√¥ng ·ªü trong k√™nh tho·∫°i n√†o.")
      # ----------------- CH·∫†Y BOT -----------------
def save_data(data, file_name=DATA_FILE):
    """Ghi ƒë√® h√†m l∆∞u ƒë·ªÉ ƒë·∫£m b·∫£o l∆∞u Global Data v√† Users."""
    data_store = users.copy()
    data_store['global_data'] = global_data
    with open(file_name, 'w', encoding='utf-8') as f:
        json.dump(data_store, f, indent=4, ensure_ascii=False)

if __name__ == "__main__":
    if not TOKEN:
        print("üö® L·ªói: Vui l√≤ng c·∫•u h√¨nh bi·∫øn m√¥i tr∆∞·ªùng DISCORD_TOKEN.")
    else:
        try:
            bot.run(TOKEN)
        except discord.errors.LoginFailure:
            print("üö® L·ªói: Token Discord kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i token c·ªßa b·∫°n.")
        except Exception as e:
            print(f"üö® L·ªói kh√¥ng x√°c ƒë·ªãnh: {e}")
          
